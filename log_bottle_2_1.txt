File 'cache/history_tmp.pkl' not found.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.

Object state: Object State: fridge(at corner), table(mounted robot_b), bottle(in fridge), cup(on table), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go to the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup '}, '9': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '11': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '12': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
robot_a is performing the task: walk to the fridge.
robot_b waiting for this task to complete...
********************Success! "walk to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Walk to the fridge.
Task-related knowledge: walk_direction, walk_distance, destination_coordinate.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
********************Success! "open the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Open the fridge.
Task-related knowledge: grasp_pos, grasp_ori, pull_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("grasp_pos", None, 1)
save_information("grasp_ori", None, 1)
save_information("pull_distance", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle.
robot_b waiting for this task to complete...
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle.
Task-related knowledge: robot_a_pick_pos, robot_a_pick_ori, robot_a_pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Close the fridge.
Correction: You cannot close the fridge because you are holding the bottle. Just put the bottle on the floor.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Go to the table.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'}, '11': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '12': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '13': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '14': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
The bottle should be placed down before closing the fridge.
Robot_a cannot close the fridge while holding the bottle.
{'1': {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'}, '8': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '11': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.

Object state: fridge(open), table(mounted robot_b), bottle(in gripper), cup(on table), robot_b(on table), robot_a(at fridge)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'}, '8': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '11': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
robot_a is performing the task: put the bottle on the floor.
robot_b waiting for this task to complete...
********************Success! "put the bottle on the floor" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle on the floor.
Task-related knowledge: place_pos, place_ori, place_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("place_pos", current_pos, 1)
save_information("place_ori", current_ori, 1)
save_information("place_height", ground_height, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the fridge.
robot_b waiting for this task to complete...
********************Success! "close the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the fridge.
Task-related knowledge: fridge_handle_pos, fridge_handle_ori, close_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle.
robot_b waiting for this task to complete...
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle.
Task-related knowledge: robot_a_pick_pos, robot_a_pick_ori, robot_a_pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: go to the table.
robot_b waiting for this task to complete...
********************Success! "go to the table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Go to the table.
Task-related knowledge: destination_pos, destination_ori, speed.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("destination_pos", current_pos, 1)
save_information("destination_ori", current_ori, 1)
save_information("speed", "default speed", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pour juice from the bottle into the cup.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pour juice from the bottle into the cup.
Correction: you cannot pour juice. Put the bottle on the table.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'}, '6': {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'}, '7': {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '11': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '12': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
robot_a cannot perform the action of pouring juice from a bottle to a cup.
{'1': {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'}, '2': {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'}, '3': {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "6": {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'},
  "7": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.
20. The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
21. robot_a cannot perform the action of pouring juice from a bottle to a cup.

Object state: fridge(closed), table(mounted robot_b, robot_a), bottle(in gripper), cup(on table), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'}, '2': {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'}, '3': {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
robot_a is performing the task: put the bottle on the table.
All robots are busy on their tasks.
********************Success! "put the bottle on the table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle on the table.
Task-related knowledge: put_pos, put_ori, put_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("put_pos", None, 1)
save_information("put_ori", None, 1)
save_information("put_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pick up the cup.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pick up the cup.
Correction: Don't pick the cup. Open the bottle first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'}, '4': {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
Before pouring juice into the cup, the bottle needs to be opened.
None
{'1': {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'}, '4': {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "6": {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'},
  "7": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'},
  "4": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.
20. The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
21. robot_a cannot perform the action of pouring juice from a bottle to a cup.
22. Before pouring juice into the cup, the bottle needs to be opened.

Object state: Fridge(closed), table(mounted robot_b, robot_a, bottle), bottle(on table), cup(on table), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'}, '4': {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
robot_a is performing the task: open the bottle.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Open the bottle.
Correction: You cannot open the bottle alone. Two robots are needed to open a bottle.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'}, '2': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'}, '4': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}}
Opening a bottle requires two robots.
robot_a cannot alone open the bottle
{'1': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'}, '2': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'}, '4': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "6": {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'},
  "7": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'},
  "4": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.
20. The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
21. robot_a cannot perform the action of pouring juice from a bottle to a cup.
22. Before pouring juice into the cup, the bottle needs to be opened.
23. Opening a bottle requires two robots.
24. robot_a cannot alone open the bottle

Object state: Fridge(closed), table(mounted robot_b, robot_a, bottle), bottle(closed, on table), cup(on table), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'}, '2': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'}, '4': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pick up the cup.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pick up the cup.
Correction: do not pick up the cup. Open the bottle with robot_a
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
Bottle needs two robots to open.
None
{'1': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "6": {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'},
  "7": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'},
  "4": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.
20. The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
21. robot_a cannot perform the action of pouring juice from a bottle to a cup.
22. Before pouring juice into the cup, the bottle needs to be opened.
23. Opening a bottle requires two robots.
24. robot_a cannot alone open the bottle
25. Bottle needs two robots to open.

Object state: Fridge(closed), table(mounted robot_b, robot_a, bottle), bottle(closed, on table), cup(on table), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '10': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
robot_a is performing the task: pick up the bottle.
robot_b waiting for this task to complete...
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle
Task-related knowledge: robot_a_pick_pos, robot_a_pick_ori, robot_a_pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the bottle with robot_b.
All robots are busy on their tasks.
********************Success! "open the bottle with robot_b" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Open the bottle with robot_b.
Task-related knowledge: robot_a_pos, robot_a_ori, robot_b_pos, robot_b_ori, open_force.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No information to save.
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: open the bottle with robot_a.
All robots are busy on their tasks.
********************Success! "open the bottle with robot_a" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Open the bottle with robot_a.
Task-related knowledge: robot_b_grasp_pos, robot_b_grasp_ori, robot_a_grasp_pos, robot_a_grasp_ori, twist_force

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the cup.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pick up the cup
Correction: You cannot pick cup with bottle in hand. Just pour the juice.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'}, '3': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pour.'}, '4': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
The robot cannot hold more than one item at a time.
robot_a has only one gripper and needs robot_b's help to open the bottle, and robot_b might not be able to move.
{'1': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pouring.'}, '2': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "6": {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'},
  "7": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'},
  "4": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pour.'},
  "4": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.
20. The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
21. robot_a cannot perform the action of pouring juice from a bottle to a cup.
22. Before pouring juice into the cup, the bottle needs to be opened.
23. Opening a bottle requires two robots.
24. robot_a cannot alone open the bottle
25. Bottle needs two robots to open.
26. The robot cannot hold more than one item at a time.
27. robot_a has only one gripper and needs robot_b's help to open the bottle, and robot_b might not be able to move.

Object state: Fridge(closed), table(mounted robot_b, robot_a, bottle), bottle(open, in robot_a's gripper), cup(on table), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pouring.'}, '2': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
robot_a is performing the task: pour juice from the bottle into the cup.
All robots are busy on their tasks.
********************Success! "pour juice from the bottle into the cup" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pour juice from the bottle into the cup.
Task-related knowledge: bottle_pos, bottle_ori, cup_pos, cup_ori, pour_angle, pour_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: hold the cup while pouring.
All robots are busy on their tasks.
********************Success! "hold the cup while pouring" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Hold the cup while pouring.
Task-related knowledge: hold_pos, hold_ori, pour_angle, pour_speed

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("hold_pos", "unknown", 1)
save_information("hold_ori", "unknown", 1)
save_information("pour_angle", "unknown", 1)
save_information("pour_speed", "unknown", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: put the bottle back on the table.
robot_b waiting for this task to complete...
********************Success! "put the bottle back on the table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle back on the table.
Task-related knowledge: put_pos, put_ori, release_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Wait
Correction: Close the bottle first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pouring.'}, '2': {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
The bottle of juice should be closed before putting it back to the fridge.
None
{'1': {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "6": {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'},
  "7": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'},
  "4": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pour.'},
  "4": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pouring.'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.
20. The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
21. robot_a cannot perform the action of pouring juice from a bottle to a cup.
22. Before pouring juice into the cup, the bottle needs to be opened.
23. Opening a bottle requires two robots.
24. robot_a cannot alone open the bottle
25. Bottle needs two robots to open.
26. The robot cannot hold more than one item at a time.
27. robot_a has only one gripper and needs robot_b's help to open the bottle, and robot_b might not be able to move.
28. The bottle of juice should be closed before putting it back to the fridge.

Object state: Fridge(closed), table(mounted robot_b, robot_a, bottle), bottle(on table, open, empty), cup(in robot_b's gripper, filled with juice), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
robot_a is performing the task: close the bottle.
robot_b waiting for this task to complete...
********************Success! "close the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the bottle.
Task-related knowledge: bottle_pos, grasp_ori, screw_direction.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: put the bottle back on the table.
robot_b waiting for this task to complete...
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Put the bottle back on the table.
Correction: Bottle is on the table. Just pick it up.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
The task requires the bottle to be filled with juice and stored in the fridge.
The robot must grasp the bottle before it can be placed in the fridge.
{'1': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "6": {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'},
  "7": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'},
  "4": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pour.'},
  "4": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pouring.'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.
20. The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
21. robot_a cannot perform the action of pouring juice from a bottle to a cup.
22. Before pouring juice into the cup, the bottle needs to be opened.
23. Opening a bottle requires two robots.
24. robot_a cannot alone open the bottle
25. Bottle needs two robots to open.
26. The robot cannot hold more than one item at a time.
27. robot_a has only one gripper and needs robot_b's help to open the bottle, and robot_b might not be able to move.
28. The bottle of juice should be closed before putting it back to the fridge.
29. The task requires the bottle to be filled with juice and stored in the fridge.
30. The robot must grasp the bottle before it can be placed in the fridge.

Object state: Fridge(closed), table(mounted robot_b, robot_a, bottle), bottle(in robot_a’s gripper, closed, empty), cup(in robot_b’s gripper, filled with juice), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
robot_a is performing the task: pick up the bottle.
robot_b waiting for this task to complete...
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle.
Task-related knowledge: robot_a_pick_pos, robot_a_pick_ori, robot_a_pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: go to the fridge.
robot_b waiting for this task to complete...
********************Success! "go to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Go to the fridge.
Task-related knowledge: navigation_coordinates, navigation_direction, navigation_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Open the fridge.
Correction: You cannot open the fridge. Just put the bottle on the floor.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
The task only asked to bring a cup of orange juice, it does not require the bottle to be put in the fridge. The bottle can be left on the floor.
robot_a is not able to open the fridge.
{'1': {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "6": {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'},
  "7": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'},
  "4": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pour.'},
  "4": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pouring.'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.
20. The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
21. robot_a cannot perform the action of pouring juice from a bottle to a cup.
22. Before pouring juice into the cup, the bottle needs to be opened.
23. Opening a bottle requires two robots.
24. robot_a cannot alone open the bottle
25. Bottle needs two robots to open.
26. The robot cannot hold more than one item at a time.
27. robot_a has only one gripper and needs robot_b's help to open the bottle, and robot_b might not be able to move.
28. The bottle of juice should be closed before putting it back to the fridge.
29. The task requires the bottle to be filled with juice and stored in the fridge.
30. The robot must grasp the bottle before it can be placed in the fridge.
31. The task only asked to bring a cup of orange juice, it does not require the bottle to be put in the fridge. The bottle can be left on the floor.
32. robot_a is not able to open the fridge.

Object state: Fridge(open), table(mounted robot_b, robot_a), bottle(in robot_a’s gripper, closed, empty), cup(in robot_b’s gripper, filled with juice), robot_b(on table), robot_a(at fridge with bottle)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}}
robot_a is performing the task: put the bottle on the floor.
robot_b waiting for this task to complete...
********************Success! "put the bottle on the floor" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle on the floor.
Task-related knowledge: place_pos, place_ori, place_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("place_pos", current_pos, 1)
save_information("place_ori", current_ori, 1)
save_information("place_height", ground_height, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Wait
Correction: Do not wait. Open the fridge and put the bottle back.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Take the cup of juice to the specific person.'}, '3': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}}
The bottle of juice needs to be put back in the fridge after pouring the juice.
robot_a is capable of opening/closing the fridge and handling the bottle.
{'1': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "6": {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'},
  "7": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'},
  "4": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pour.'},
  "4": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pouring.'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Take the cup of juice to the specific person.'},
  "3": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.
20. The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
21. robot_a cannot perform the action of pouring juice from a bottle to a cup.
22. Before pouring juice into the cup, the bottle needs to be opened.
23. Opening a bottle requires two robots.
24. robot_a cannot alone open the bottle
25. Bottle needs two robots to open.
26. The robot cannot hold more than one item at a time.
27. robot_a has only one gripper and needs robot_b's help to open the bottle, and robot_b might not be able to move.
28. The bottle of juice should be closed before putting it back to the fridge.
29. The task requires the bottle to be filled with juice and stored in the fridge.
30. The robot must grasp the bottle before it can be placed in the fridge.
31. The task only asked to bring a cup of orange juice, it does not require the bottle to be put in the fridge. The bottle can be left on the floor.
32. robot_a is not able to open the fridge.
33. The bottle of juice needs to be put back in the fridge after pouring the juice.
34. robot_a is capable of opening/closing the fridge and handling the bottle.

Object state: Fridge(open), table(mounted robot_b, robot_a), bottle(on floor, closed, empty), cup(in robot_b’s gripper, filled with juice), robot_b(on table), robot_a(at fridge)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}}
robot_a is performing the task: pick up the bottle.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pick up the bottle.
Correction: Open the fridge first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}}
None
Robot should first open the fridge before picking up the bottle.
{'1': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Walk to the fridge.', 'robot_b': 'wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Go to the fridge.', 'robot_b': 'Pick up the cup'},
  "11": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "6": {'robot_b': 'Pour juice from the bottle into the cup.', 'robot_a': 'Wait'},
  "7": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the table.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice from the bottle into the cup.'},
  "4": {'robot_a': 'Pick up the bottle from the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle with robot_b.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pour.'},
  "4": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice from the bottle into the cup.', 'robot_b': 'Hold the cup while pouring.'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back on the table.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go to the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the cup of juice to the specific person.'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Take the cup of juice to the specific person.'},
  "3": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}
}

Instruction: Bring a cup of orange juice.
Response:
{
  "1": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_b can only hold one item at a time.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. The bottle should be placed down before closing the fridge.
19. Robot_a cannot close the fridge while holding the bottle.
20. The task requires pouring juice from the bottle to the cup. But based on the human correction, the robot_a is not capable of pouring juice.
21. robot_a cannot perform the action of pouring juice from a bottle to a cup.
22. Before pouring juice into the cup, the bottle needs to be opened.
23. Opening a bottle requires two robots.
24. robot_a cannot alone open the bottle
25. Bottle needs two robots to open.
26. The robot cannot hold more than one item at a time.
27. robot_a has only one gripper and needs robot_b's help to open the bottle, and robot_b might not be able to move.
28. The bottle of juice should be closed before putting it back to the fridge.
29. The task requires the bottle to be filled with juice and stored in the fridge.
30. The robot must grasp the bottle before it can be placed in the fridge.
31. The task only asked to bring a cup of orange juice, it does not require the bottle to be put in the fridge. The bottle can be left on the floor.
32. robot_a is not able to open the fridge.
33. The bottle of juice needs to be put back in the fridge after pouring the juice.
34. robot_a is capable of opening/closing the fridge and handling the bottle.
35. Robot should first open the fridge before picking up the bottle.

Object state: Fridge(open), table(mounted robot_b, robot_a), bottle(on floor, closed, empty), cup(in robot_b’s gripper, filled with juice), robot_b(on table), robot_a(at fridge)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] (No changes as the task was to wait)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}}
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
********************Success! "open the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Open the fridge.
Task-related knowledge: grasp_pos, grasp_ori, pull_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("grasp_pos", None, 1)
save_information("grasp_ori", None, 1)
save_information("pull_distance", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle.
robot_b waiting for this task to complete...
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle.
Task-related knowledge: robot_a_pick_pos, robot_a_pick_ori, robot_a_pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: put the bottle in the fridge.
robot_b waiting for this task to complete...
********************Success! "put the bottle in the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle in the fridge.
Task-related knowledge: put_pos, put_ori, lift_height, open_fridge_instruction

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No information to save
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the fridge.
robot_b waiting for this task to complete...
********************Success! "close the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the fridge.
Task-related knowledge: fridge_handle_pos, fridge_handle_ori, close_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
File 'cache/history_tmp.pkl' has been deleted successfully.
---------------------------Ready to move to next instruction...---------------------------
File 'cache/history_tmp.pkl' not found.