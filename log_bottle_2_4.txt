Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.

Object state: Object State: fridge(at corner), table(mounted robot_b), bottle(in fridge), cup(on table), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Go to the cup'}, '5': {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'}, '6': {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'}, '7': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge', 'robot_b': 'Leave the cup on table'}, '10': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '11': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '12': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
robot_a is performing the task: go to the fridge.
robot_b waiting for this task to complete...
********************Success! "go to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Go to the fridge
Task-related knowledge: destination_pos, destination_ori

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("destination_pos", "fridge", 1)
save_information("destination_ori", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
********************Success! "open the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Open the fridge
Task-related knowledge: fridge_handle_pos, fridge_handle_ori, pull_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: take the bottle out of the fridge.
robot_b waiting for this task to complete...
********************Success! "take the bottle out of the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Take the bottle out of the fridge
Task-related knowledge: open_fridge_pos, open_fridge_ori, grasp_bottle_pos, grasp_bottle_ori, pullout_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the fridge.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Close the fridge
Correction: you cannot close the fridge, ou should put the bottle on the floor first and then close the firdge
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'}, '5': {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'}, '6': {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'}, '7': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'}, '9': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '10': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'}, '11': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '12': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '13': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '14': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
None
robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
{'1': {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'}, '2': {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'}, '3': {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'}, '4': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'}, '6': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '7': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'}, '8': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '10': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '11': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.

Object state: fridge(open), table(mounted robot_b), bottle(in robot_a hand), cup(on table), robot_b(on table), robot_a(at fridge)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'}, '2': {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'}, '3': {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'}, '4': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'}, '6': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '7': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'}, '8': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '10': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '11': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
robot_a is performing the task: put the bottle on the floor.
All robots are busy on their tasks.
********************Success! "put the bottle on the floor" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle on the floor
Task-related knowledge: put_pos, put_ori, put_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("put_pos", None, 1)
save_information("put_ori", None, 1)
save_information("put_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: go to the cup.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Go to the cup
Correction: robot_b cannot move, and you should wait
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'}, '4': {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'}, '5': {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'}, '6': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '9': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
The cup of juice should be brought to the human.
robot_b cannot move.
{'1': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'}, '4': {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'}, '5': {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'}, '6': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '9': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
24. The cup of juice should be brought to the human.
25. robot_b cannot move.

Object state: fridge(open), table(mounted robot_b, cup on table), bottle(on the floor), robot_b(on table), robot_a(at fridge)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'}, '4': {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'}, '5': {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'}, '6': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '9': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
robot_a is performing the task: close the fridge.
robot_b waiting for this task to complete...
********************Success! "close the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the fridge
Task-related knowledge: push_pos, push_ori, push_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("push_pos", None, 1)
save_information("push_ori", None, 1)
save_information("push_distance", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle from the floor.
robot_b waiting for this task to complete...
********************Success! "pick up the bottle from the floor" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle from the floor
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the bottle.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Open the bottle
Correction: robot_a and robot_b should both work on openning the bottle
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'}, '3': {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'}, '4': {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Help robot_a open bottle'}, '5': {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'}, '6': {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'}, '7': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'}, '8': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '10': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
The bottle requires both robots to be opened.
None
{'1': {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'}, '2': {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'}, '3': {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'}, '4': {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'}, '5': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '8': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Help robot_a open bottle'},
  "5": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "8": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
24. The cup of juice should be brought to the human.
25. robot_b cannot move.
26. The bottle requires both robots to be opened.

Object state: fridge(closed), table(mounted robot_b, cup on table), bottle(in gripper)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'}, '2': {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'}, '3': {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'}, '4': {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'}, '5': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '8': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
robot_a is performing the task: signal robot_b to assist with bottle.
All robots are busy on their tasks.
********************Success! "signal robot_b to assist with bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Signal robot_b to assist with bottle
Task-related knowledge: signal_type, signal_timing, robot_b_pos, robot_b_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pick up the cup.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pick up the cup
Correction: robot_b shouldn't pick up the cup, and robot_b should help robot_a to open the bottle
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'wait'}, '2': {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'}, '3': {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'}, '4': {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'}, '5': {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'}, '6': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '9': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
None
robot_a and robot_b should cooperate to open the bottle.
{'1': {'robot_a': 'Put the cup back on the table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'}, '3': {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'}, '4': {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'}, '5': {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'}, '6': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '9': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Help robot_a open bottle'},
  "5": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "8": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
24. The cup of juice should be brought to the human.
25. robot_b cannot move.
26. The bottle requires both robots to be opened.
27. robot_a and robot_b should cooperate to open the bottle.

Object state: fridge(closed), table(mounted robot_b, cup on table, robot_b assisted with bottle), bottle(in robot_a's gripper)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the cup back on the table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'}, '3': {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'}, '4': {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'}, '5': {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'}, '6': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '9': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
robot_a is performing the task: put the cup back on the table.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Put the cup back on the table
Correction: robot_a cannot put the cup, and the robot_a should go to the table
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'}, '3': {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'}, '4': {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'}, '5': {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'}, '6': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '9': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
The cup must be placed on the table for juice to be poured in.
robot_a can not put objects on the table and the objects should be at the same surface level as robot_a for robot_a to perform actions.
{'1': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'}, '3': {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'}, '4': {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'}, '5': {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'}, '6': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '9': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Help robot_a open bottle'},
  "5": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "8": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
24. The cup of juice should be brought to the human.
25. robot_b cannot move.
26. The bottle requires both robots to be opened.
27. robot_a and robot_b should cooperate to open the bottle.
28. The cup must be placed on the table for juice to be poured in.
29. robot_a can not put objects on the table and the objects should be at the same surface level as robot_a for robot_a to perform actions.

Object state: fridge(closed), table(with cup and mounted robot_b, robot_b assisted with bottle), bottle(in robot_a's gripper)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'}, '3': {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'}, '4': {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'}, '5': {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'}, '6': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '9': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
robot_a is performing the task: go to the table.
robot_b waiting for this task to complete...
********************Success! "go to the table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Go to the table
Task-related knowledge: destination_coordinates, robot_a_ori, speed.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No information to save.
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle.
All robots are busy on their tasks.
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle
Task-related knowledge: pick_pos, pick_ori, pickup_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("pick_pos", current_pos, 2)
save_information("pick_ori", current_ori, 2)
save_information("pickup_height", None, 2)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: move to assist robot_a with the bottle.
All robots are busy on their tasks.
********************Success! "move to assist robot_a with the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Move to assist robot_a with the bottle
Task-related knowledge: robot_b_pos, robot_a_pos, assist_bottle_ori, assist_bottle_pos.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open bottle with robot_b.
All robots are busy on their tasks.
********************Success! "open bottle with robot_b" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Open bottle with robot_b
Task-related knowledge: robot_a_pos, robot_a_ori, robot_b_pos, robot_b_ori, bottle_pos, bottle_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("robot_a_pos", robot_a_pos, 1)
save_information("robot_a_ori", robot_a_ori, 1)
save_information("robot_b_pos", robot_b_pos, 1)
save_information("robot_b_ori", robot_b_ori, 1)
save_information("bottle_pos", bottle_pos, 1)
save_information("bottle_ori", bottle_ori, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: assist robot_a to open the bottle.
All robots are busy on their tasks.
********************Success! "assist robot_a to open the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Assist robot_a to open the bottle
Task-related knowledge: assist_pos, assist_ori, apply_force_direction, apply_force_magnitude.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pour juice into cup on table.
All robots are busy on their tasks.
********************Success! "pour juice into cup on table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pour juice into cup on table
Task-related knowledge: pour_start_pos, pour_start_ori, pour_end_pos, pour_end_ori, pour_angle.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: hold bottle for a while.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Hold bottle for a while
Correction: robot_b is not holding the bottle, and robot_a should close the bottle
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'}, '3': {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'}, '4': {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '6': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '9': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
The bottle should be closed after pouring the juice.
Robot_b cannot hold the bottle.
{'1': {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '6': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Help robot_a open bottle'},
  "5": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "8": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
24. The cup of juice should be brought to the human.
25. robot_b cannot move.
26. The bottle requires both robots to be opened.
27. robot_a and robot_b should cooperate to open the bottle.
28. The cup must be placed on the table for juice to be poured in.
29. robot_a can not put objects on the table and the objects should be at the same surface level as robot_a for robot_a to perform actions.
30. The bottle should be closed after pouring the juice.
31. Robot_b cannot hold the bottle.

Object state: fridge(closed), table(with cup full of juice, mounted robot_b, robot_b assisted with bottle, robot_a with bottle), bottle(open, partially empty, with robot_a)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '6': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
robot_a is performing the task: pour juice into cup on table.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pour juice into cup on table
Correction: you have already put the juice, and now robot_a should close the bottle
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '6': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
After pouring juice into a cup, the bottle should be closed.
None
{'1': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '5': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Help robot_a open bottle'},
  "5": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "8": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
24. The cup of juice should be brought to the human.
25. robot_b cannot move.
26. The bottle requires both robots to be opened.
27. robot_a and robot_b should cooperate to open the bottle.
28. The cup must be placed on the table for juice to be poured in.
29. robot_a can not put objects on the table and the objects should be at the same surface level as robot_a for robot_a to perform actions.
30. The bottle should be closed after pouring the juice.
31. Robot_b cannot hold the bottle.
32. After pouring juice into a cup, the bottle should be closed.

Object state: fridge(closed), table(with cup full of juice, mounted robot_b, robot_b assisted with bottle, robot_a with bottle), bottle(open, partially empty, with robot_a)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '5': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
robot_a is performing the task: close the bottle.
robot_b waiting for this task to complete...
********************Success! "close the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the bottle
Task-related knowledge: bottle_grasp_pos, bottle_grasp_ori, twist_force


Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: put the bottle back into the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Put the bottle back into the fridge
Correction: robot_a shouldn't put the bottle back to fridge now, and the robot_a should go to the fridge firstly
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '6': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
The task requires to serve a full cup of juice, the bottle shouldn't have been closed and put back into the fridge until the cup is filled.
robot_a needs to approach the fridge before interact with it.
{'1': {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '6': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Help robot_a open bottle'},
  "5": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "8": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
24. The cup of juice should be brought to the human.
25. robot_b cannot move.
26. The bottle requires both robots to be opened.
27. robot_a and robot_b should cooperate to open the bottle.
28. The cup must be placed on the table for juice to be poured in.
29. robot_a can not put objects on the table and the objects should be at the same surface level as robot_a for robot_a to perform actions.
30. The bottle should be closed after pouring the juice.
31. Robot_b cannot hold the bottle.
32. After pouring juice into a cup, the bottle should be closed.
33. The task requires to serve a full cup of juice, the bottle shouldn't have been closed and put back into the fridge until the cup is filled.
34. robot_a needs to approach the fridge before interact with it.

Object state: fridge(closed), table(with cup full of juice, mounted robot_b, robot_b assisted with bottle, robot_a with closed bottle), bottle(closed, partially empty, with robot_a)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '6': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
robot_a is performing the task: approach the fridge.
robot_b waiting for this task to complete...
********************Success! "approach the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Approach the fridge
Task-related knowledge: approach_pos, approach_ori, travel_distance

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("approach_pos", None, 1)
save_information("approach_ori", None, 1)
save_information("travel_distance", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Open the fridge
Correction: you should put the bottle on the floor firstly, and then open the fridge
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '8': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
None
robot_a can only perform one task at a time, either holding the bottle or open the fridge, but not both at the same time.
{'1': {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '7': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Help robot_a open bottle'},
  "5": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "8": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
24. The cup of juice should be brought to the human.
25. robot_b cannot move.
26. The bottle requires both robots to be opened.
27. robot_a and robot_b should cooperate to open the bottle.
28. The cup must be placed on the table for juice to be poured in.
29. robot_a can not put objects on the table and the objects should be at the same surface level as robot_a for robot_a to perform actions.
30. The bottle should be closed after pouring the juice.
31. Robot_b cannot hold the bottle.
32. After pouring juice into a cup, the bottle should be closed.
33. The task requires to serve a full cup of juice, the bottle shouldn't have been closed and put back into the fridge until the cup is filled.
34. robot_a needs to approach the fridge before interact with it.
35. robot_a can only perform one task at a time, either holding the bottle or open the fridge, but not both at the same time.

Object state: fridge(closed, approached by robot), table(with cup full of juice, mounted robot_b), bottle(closed, partially empty, at robot_a's feet)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'}, '7': {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}}
robot_a is performing the task: put the bottle on the floor.
robot_b waiting for this task to complete...
********************Success! "put the bottle on the floor" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle on the floor
Task-related knowledge: put_pos, put_ori, put_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("put_pos", None, 1)
save_information("put_ori", None, 1)
save_information("put_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
********************Success! "open the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Open the fridge
Task-related knowledge: fridge_handle_pos, fridge_handle_ori, pull_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle.
robot_b waiting for this task to complete...
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle
Task-related knowledge: pick_pos, pick_ori, pickup_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("pick_pos", current_pos, 2)
save_information("pick_ori", current_ori, 2)
save_information("pickup_height", None, 2)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: put the bottle back into the fridge.
robot_b waiting for this task to complete...
********************Success! "put the bottle back into the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle back into the fridge
Task-related knowledge: place_pos, place_ori, push_distance

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("place_pos", None, 1)
save_information("place_ori", None, 1)
save_information("push_distance", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the fridge.
robot_b waiting for this task to complete...
********************Success! "close the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the fridge
Task-related knowledge: push_pos, push_ori, push_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("push_pos", None, 1)
save_information("push_ori", None, 1)
save_information("push_distance", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the cup from the table.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pick up the cup from the table
Correction: robot_a is not near the table, and robot_a cannot pick up the cup. Robot_b should pick up the cup
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup from the table'}, '7': {'robot_a': 'Wait', 'robot_b': 'Serve the cup of juice'}}
None
robot_a is not near the table and robot_a cannot pick up the cup.
{'1': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup from the table'}, '4': {'robot_a': 'Wait', 'robot_b': 'Serve the cup of juice'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Help robot_a open bottle'},
  "5": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "8": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup from the table'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Serve the cup of juice'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
24. The cup of juice should be brought to the human.
25. robot_b cannot move.
26. The bottle requires both robots to be opened.
27. robot_a and robot_b should cooperate to open the bottle.
28. The cup must be placed on the table for juice to be poured in.
29. robot_a can not put objects on the table and the objects should be at the same surface level as robot_a for robot_a to perform actions.
30. The bottle should be closed after pouring the juice.
31. Robot_b cannot hold the bottle.
32. After pouring juice into a cup, the bottle should be closed.
33. The task requires to serve a full cup of juice, the bottle shouldn't have been closed and put back into the fridge until the cup is filled.
34. robot_a needs to approach the fridge before interact with it.
35. robot_a can only perform one task at a time, either holding the bottle or open the fridge, but not both at the same time.
36. robot_a is not near the table and robot_a cannot pick up the cup.

Object state: fridge(closed, not approached by robot, not full), table(with cup full of juice, mounted robot_b), bottle(closed, partially empty, in fridge)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup from the table'}, '4': {'robot_a': 'Wait', 'robot_b': 'Serve the cup of juice'}}
robot_a is performing the task: put the bottle back into the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Put the bottle back into the fridge
Correction: the bottle is already in the firdge, and the robot_a cannot put the bottle back. Robot_b should pick up the cup right now
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup from the table'}, '2': {'robot_a': 'Wait', 'robot_b': 'Serve the cup of juice'}}
The bottle is already in the fridge, and the robot_a cannot put the bottle back. Robot_b should pick up the cup right now.
robot_a can not interact with objects that are already in the closed fridge.
{'1': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup from the table'}, '2': {'robot_a': 'Wait', 'robot_b': 'Serve the cup of juice'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Take the bottle out of the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle from the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'Pick up the cup'},
  "4": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Help robot_a open bottle'},
  "5": {'robot_a': 'Pour juice into cup held by robot_b', 'robot_b': 'Hold cup for a while'},
  "6": {'robot_a': 'Close the bottle', 'robot_b': 'Hold cup for a while'},
  "7": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Leave the cup on table'},
  "8": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Signal robot_b to assist with bottle', 'robot_b': 'wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Hold bottle for a while'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Hold bottle for a while'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle', 'robot_b': 'Move to assist robot_a with the bottle'},
  "3": {'robot_a': 'Open bottle with robot_b', 'robot_b': 'Assist robot_a to open the bottle'},
  "4": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Pour juice into cup on table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Approach the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup from the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Serve the cup of juice', 'robot_b': 'Wait'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the floor', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Put the bottle back into the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup from the table'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Serve the cup of juice'}
}

Instruction: bring a cup of juice
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup from the table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Serve the cup of juice'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. Before pouring, the bottle needs to be opened.
13. Opening the wine bottle requires both robots.
14. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
15. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
16. Robot should pour wine while the cup is on the table.
17. robot_b can only hold one item at a time.
18. The wine bottle needs to be returned to the fridge after pouring.
19. The bottle must be closed before it can be placed back in the fridge.
20. robot_b needs to go to fridge first before storing anything inside
21. The fridge door needs to be opened before anything can be put in or taken out.
22. Robot_b cannot perform any other action while holding the bottle.
23. robot_a can't perform two tasks at once, like holding the bottle and closing the fridge.
24. The cup of juice should be brought to the human.
25. robot_b cannot move.
26. The bottle requires both robots to be opened.
27. robot_a and robot_b should cooperate to open the bottle.
28. The cup must be placed on the table for juice to be poured in.
29. robot_a can not put objects on the table and the objects should be at the same surface level as robot_a for robot_a to perform actions.
30. The bottle should be closed after pouring the juice.
31. Robot_b cannot hold the bottle.
32. After pouring juice into a cup, the bottle should be closed.
33. The task requires to serve a full cup of juice, the bottle shouldn't have been closed and put back into the fridge until the cup is filled.
34. robot_a needs to approach the fridge before interact with it.
35. robot_a can only perform one task at a time, either holding the bottle or open the fridge, but not both at the same time.
36. robot_a is not near the table and robot_a cannot pick up the cup.
37. The bottle is already in the fridge, and the robot_a cannot put the bottle back. Robot_b should pick up the cup right now.
38. robot_a can not interact with objects that are already in the closed fridge.

Object state: fridge(closed, not approached by robot, not full), table(with cup full of juice, mounted robot_b), bottle(closed, partially empty, in fridge)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: Nothing changed because the action 'wait' does not affect anything in the environment.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper'] 

(Note: there is no change in the object state in a "wait" task.)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup from the table'}, '2': {'robot_a': 'Wait', 'robot_b': 'Serve the cup of juice'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pick up the cup from the table.
robot_a waiting for this task to complete...
********************Success! "pick up the cup from the table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Pick up the cup from the table
Task-related knowledge: pick_pos, pick_ori, pickup_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("pick_pos", None, 1)
save_information("pick_ori", None, 1)
save_information("pickup_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: serve the cup of juice.
robot_a waiting for this task to complete...
********************Success! "serve the cup of juice" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Serve the cup of juice
Task-related knowledge: serve_pos, serve_ori, pour_angle.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
File 'cache/history_tmp.pkl' has been deleted successfully.
---------------------------Ready to move to next instruction...---------------------------
File 'cache/history_tmp.pkl' not found.