Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.

Object state: Object State: fridge(at corner), table(mounted robot_b), bottle(in fridge), cup(on table), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Go to the cup'}, '5': {'robot_a': 'Go to the table', 'robot_b': 'Pick up the cup'}, '6': {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}, '7': {'robot_a': 'Go back to the fridge', 'robot_b': 'Put down the cup'}, '8': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '10': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: go to the fridge.
robot_b waiting for this task to complete...
********************Success! "go to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Go to the fridge
Task-related knowledge: destination_pos, destination_ori, travel_distance

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("destination_pos", None, 1)
save_information("destination_ori", None, 1)
save_information("travel_distance", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
********************Success! "open the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Open the fridge
Task-related knowledge: grasp_pos, grasp_ori, pull_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No information updates or additional waypoints needed.
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle of orange juice.
robot_b waiting for this task to complete...
********************Success! "pick up the bottle of orange juice" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle of orange juice
Task-related knowledge: pick_pos, pick_ori, pickup_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the fridge.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Close the fridge
Correction: set the bottle on the ground before closing the fridge
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'}, '4': {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'}, '5': {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'}, '6': {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'}, '7': {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'}, '8': {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}, '9': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '10': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '11': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '12': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
None
robot is not designed to multitask i.e., to close the fridge while holding a bottle.
{'1': {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'}, '2': {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'}, '3': {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'}, '5': {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.

Object state: fridge(open), table(mounted robot_b), bottle(in robot_a gripper), cup(on table), robot_b(on table), robot_a(at fridge, gripping bottle of orange juice)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'}, '2': {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'}, '3': {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'}, '5': {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: set the bottle on the ground.
All robots are busy on their tasks.
********************Success! "set the bottle on the ground" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Set the bottle on the ground
Task-related knowledge: set_pos, set_ori, drop_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: go to the cup.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Go to the cup
Correction: robot_b is mounted. robot_b wait.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'}, '7': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}, '9': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '10': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '11': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '12': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
None
robot_b is mounted on the table and cannot move.
{'1': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}, '8': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '10': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '11': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.

Object state: fridge(open), table(mounted robot_b), bottle(on ground), cup(on table), robot_b(on table), robot_a(at fridge, empty gripper)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}, '8': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '10': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '11': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: close the fridge.
robot_b waiting for this task to complete...
********************Success! "close the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the fridge
Task-related knowledge: close_pos, close_ori, push_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: go to the cup.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Go to the cup
Correction: robot_a needs to pick up bottle first
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '9': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '10': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '11': {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'}, '12': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}, '13': {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'}, '14': {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}}
None.
robot_a can only hold one item at times.
{'1': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.

Object state: fridge(closed), table(mounted robot_b), bottle(on ground), cup(on table), robot_b(on table), robot_a(at fridge, empty gripper)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: go back to the fridge.
robot_b waiting for this task to complete...
********************Success! "go back to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Go back to the fridge
Task-related knowledge: destination_pos, orientation, travel_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("destination_pos", None, 0)
save_information("orientation", None, 0)
save_information("travel_distance", None, 0)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: take out the bottle of orange juice.
robot_b waiting for this task to complete...
********************Success! "take out the bottle of orange juice" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Take out the bottle of orange juice
Task-related knowledge: grasp_pos, grasp_ori, pull_distance, pick_pos, pick_ori, pickup_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: go to the cup.
robot_b waiting for this task to complete...
********************Success! "go to the cup" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Go to the cup
Task-related knowledge: destination_pos, destination_ori, travel_distance

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("destination_pos", "cup location", 1)
save_information("destination_ori", "facing cup", 1)
save_information("travel_distance", "distance to cup", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the cup.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pick up the cup
Correction: robot_a needs to set the bottle down first
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'}, '3': {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'}, '7': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '10': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '11': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
The bottle needs to be set down before picking up the cup.
robot_a can only hold one item at a time.
{'1': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'}, '6': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '8': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '9': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '10': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.

Object state: fridge(open), table(mounted robot_b), bottle(in robot_a gripper), cup(on table), robot_b(at cup), robot_a(at fridge)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'}, '6': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '8': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '9': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '10': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: go back to the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Go back to the fridge
Correction: robot_a needs to put the bottle on the table
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go back to the table', 'robot_b': 'Wait'}, '6': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '8': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '9': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '10': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
None
robot_a cannot carry the bottle while moving
{'1': {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go back to the table', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '8': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '9': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '10': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '11': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '12': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving

Object state: fridge(open), table(mounted robot_b), bottle(in robot_a gripper), cup(on table), robot_b(at cup), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Go back to the table', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '8': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '9': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '10': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '11': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '12': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: put the bottle on the table.
robot_b waiting for this task to complete...
********************Success! "put the bottle on the table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle on the table
Task-related knowledge: put_pos, put_ori, drop_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("put_pos", None, 1)
save_information("put_ori", None, 1)
save_information("drop_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: go back to the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Go back to the fridge
Correction: robot_a should remain at the table and open the bottle
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Go back to the table', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '8': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '10': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
The bottle must be opened at the table.
None.
{'1': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go back to the table', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '7': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving
24. The bottle must be opened at the table.

Object state: fridge(open), table(mounted robot_b), bottle(on table), cup(on table), robot_b(at cup), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Open the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Go to the cup', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Go back to the table', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '7': {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'}, '8': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '9': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: open the bottle.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Open the bottle
Correction: robot_b needs to help robot_a open the bottle
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Go to the cup', 'robot_b': 'Go to the bottle'}, '2': {'robot_a': 'Pick up the cup', 'robot_b': 'Open the bottle with robot_a'}, '3': {'robot_a': 'Go back to the table', 'robot_b': 'Pour juice into the cup'}, '4': {'robot_a': 'Wait', 'robot_b': 'Close the bottle'}, '5': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
Opening a bottle requires two robots.
robot_a cannot open the bottle alone.
{'1': {'robot_a': 'Go to the bottle', 'robot_b': 'Help robot_a open the bottle'}, '2': {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'}, '4': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the cup', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Pick up the cup', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Go back to the table', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving
24. The bottle must be opened at the table.
25. Opening a bottle requires two robots.
26. robot_a cannot open the bottle alone.

Object state: fridge(open), table(mounted robot_b), bottle(on table), cup(on table), robot_b(at cup), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Go to the bottle', 'robot_b': 'Help robot_a open the bottle'}, '2': {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'}, '4': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: go to the bottle.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Go to the bottle
Correction: robot_a and robot_b should work together to open the bottle
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Go to the bottle', 'robot_b': 'Go to the bottle'}, '2': {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'}, '3': {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'}, '5': {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
Opening the bottle requires two robots to work together.
None
{'1': {'robot_a': 'Wait', 'robot_b': 'Go to the bottle'}, '2': {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'}, '3': {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'}, '5': {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the cup', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Pick up the cup', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Go back to the table', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving
24. The bottle must be opened at the table.
25. Opening a bottle requires two robots.
26. robot_a cannot open the bottle alone.
27. Opening the bottle requires two robots to work together.

Object state: fridge(open), table(mounted robot_b), bottle(on table), cup(on table), robot_b(at cup), robot_a(at bottle)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Go to the bottle'}, '2': {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'}, '3': {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'}, '5': {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Wait
Correction: both robots are already at the bottle. the robots need to work together to open the bottle
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'}, '2': {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'}, '4': {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'}, '5': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
None.
both robots have to work together to open the bottle
{'1': {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'}, '2': {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'}, '4': {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'}, '5': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the cup', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Pick up the cup', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Go back to the table', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "4": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving
24. The bottle must be opened at the table.
25. Opening a bottle requires two robots.
26. robot_a cannot open the bottle alone.
27. Opening the bottle requires two robots to work together.
28. both robots have to work together to open the bottle

Object state: fridge(open), table(mounted robot_b), bottle(on table), cup(on table), robot_b(at bottle), robot_a(at bottle)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'}, '2': {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'}, '4': {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'}, '5': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: hold the bottle.
All robots are busy on their tasks.
********************Success! "hold the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Hold the bottle
Task-related knowledge: hold_pos, hold_ori, grip_strength

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("hold_pos", None, 1)
save_information("hold_ori", None, 1)
save_information("grip_strength", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: help robot_a open the bottle.
All robots are busy on their tasks.
********************Success! "help robot_a open the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Help robot_a open the bottle
Task-related knowledge: bottle_pos, bottle_ori, applied_force

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: go to the cup.
All robots are busy on their tasks.
********************Success! "go to the cup" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Go to the cup
Task-related knowledge: destination_pos, destination_ori, travel_distance

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("destination_pos", "cup location", 1)
save_information("destination_ori", "facing cup", 1)
save_information("travel_distance", "distance to cup", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pour juice into the cup.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pour juice into the cup
Correction: robot_b is not holding the bottle. let robot_a pour the juice.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'}, '2': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '3': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '4': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
Only the robot that actually holds the bottle can pour the juice.
None
{'1': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the cup', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Pick up the cup', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Go back to the table', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "4": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving
24. The bottle must be opened at the table.
25. Opening a bottle requires two robots.
26. robot_a cannot open the bottle alone.
27. Opening the bottle requires two robots to work together.
28. both robots have to work together to open the bottle
29. Only the robot that actually holds the bottle can pour the juice.

Object state: fridge(open), table(mounted robot_b), bottle(open, in robot_a's gripper), cup(on table, near robot_b), robot_b(at cup), robot_a(holding open bottle)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: pour juice into the cup.
robot_b waiting for this task to complete...
********************Success! "pour juice into the cup" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pour juice into the cup
Task-related knowledge: pouring_pos, pouring_ori, tilt_angle, fill_level.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the bottle.
robot_b waiting for this task to complete...
********************Success! "close the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the bottle
Task-related knowledge: cap_pos, cap_ori, close_force.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No information detected to be stored.
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: return the bottle to the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Return the bottle to the fridge
Correction: break the task down. robot_a should go to fridge first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
The robot must move to the location of the fridge to place the juice bottle back in it.
None
{'1': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the cup', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Pick up the cup', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Go back to the table', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "4": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving
24. The bottle must be opened at the table.
25. Opening a bottle requires two robots.
26. robot_a cannot open the bottle alone.
27. Opening the bottle requires two robots to work together.
28. both robots have to work together to open the bottle
29. Only the robot that actually holds the bottle can pour the juice.
30. The robot must move to the location of the fridge to place the juice bottle back in it.

Object state: fridge(open), table(mounted robot_b), bottle(closed, in robot_a's gripper), cup(on table, near robot_b, filled), robot_b(at cup), robot_a(holding closed bottle)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: go to the fridge.
robot_b waiting for this task to complete...
********************Success! "go to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Go to the fridge
Task-related knowledge: destination_pos, destination_ori, travel_distance

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("destination_pos", None, 1)
save_information("destination_ori", None, 1)
save_information("travel_distance", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: return the bottle to the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Return the bottle to the fridge
Correction: break the task down more. robot_a needs to set the bottle down and then open the fridge.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'}, '3': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '5': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '7': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
The task should be properly decomposed. You cannot return the bottle to fridge without putting the bottle down and opening the fridge first.
robot_a can only do one task at a time
{'1': {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '4': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the cup', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Pick up the cup', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Go back to the table', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "4": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving
24. The bottle must be opened at the table.
25. Opening a bottle requires two robots.
26. robot_a cannot open the bottle alone.
27. Opening the bottle requires two robots to work together.
28. both robots have to work together to open the bottle
29. Only the robot that actually holds the bottle can pour the juice.
30. The robot must move to the location of the fridge to place the juice bottle back in it.
31. The task should be properly decomposed. You cannot return the bottle to fridge without putting the bottle down and opening the fridge first.
32. robot_a can only do one task at a time

Object state: fridge(closed, robot_a near), table(mounted robot_b), bottle(closed, in robot_a's gripper), cup(on table, near robot_b, filled), robot_b(at cup), robot_a(at fridge, holding closed bottle)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '4': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: set down the bottle.
robot_b waiting for this task to complete...
********************Success! "set down the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Set down the bottle
Task-related knowledge: setdown_pos, setdown_ori, setdown_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("setdown_pos", "unknown", 1)
save_information("setdown_ori", "unknown", 1)
save_information("setdown_height", "unknown", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
********************Success! "open the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Open the fridge
Task-related knowledge: grasp_pos, grasp_ori, pull_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No information updates or additional waypoints needed.
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle.
robot_b waiting for this task to complete...
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("pick_pos", current_pos, 1)
save_information("pick_ori", current_ori, 1)
save_information("pickup_height", "not specified", 0)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: return the bottle to the fridge.
robot_b waiting for this task to complete...
********************Success! "return the bottle to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Return the bottle to the fridge
Task-related knowledge: pick_pos, pick_ori, return_pos, return_ori

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No additional feedback required as the task was successfully completed without any human intervention. No additional waypoints needed.
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the cup.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pick up the cup
Correction: robot_a needs to close the fridge first
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}}
Need to close the fridge after taking bottle.
None
{'1': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '3': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the cup', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Pick up the cup', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Go back to the table', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "4": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving
24. The bottle must be opened at the table.
25. Opening a bottle requires two robots.
26. robot_a cannot open the bottle alone.
27. Opening the bottle requires two robots to work together.
28. both robots have to work together to open the bottle
29. Only the robot that actually holds the bottle can pour the juice.
30. The robot must move to the location of the fridge to place the juice bottle back in it.
31. The task should be properly decomposed. You cannot return the bottle to fridge without putting the bottle down and opening the fridge first.
32. robot_a can only do one task at a time
33. Need to close the fridge after taking bottle.

Object state: fridge(open, robot_a near, bottle in), table(mounted robot_b), bottle(with robot_a), cup(on table, near robot_b, filled), robot_b(at cup), robot_a(at fridge, holding bottle)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}, '2': {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'}, '3': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}}
robot_a is performing the task: close the fridge.
robot_b waiting for this task to complete...
********************Success! "close the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the fridge
Task-related knowledge: close_pos, close_ori, push_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the cup.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pick up the cup
Correction: robot_a is not at the table. robot_b should pick up the cup since it's at the table
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'}, '2': {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Hold the cup'}, '3': {'robot_a': 'Move to the table', 'robot_b': 'Wait'}}
The robot who is near the cup (robot_b) should be the one to pick it up.
robot_a is not currently near the cup.
{'1': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Pick up the cup'}, '2': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the cup', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Pick up the cup', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Go back to the table', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "4": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "2": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Hold the cup'},
  "3": {'robot_a': 'Move to the table', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving
24. The bottle must be opened at the table.
25. Opening a bottle requires two robots.
26. robot_a cannot open the bottle alone.
27. Opening the bottle requires two robots to work together.
28. both robots have to work together to open the bottle
29. Only the robot that actually holds the bottle can pour the juice.
30. The robot must move to the location of the fridge to place the juice bottle back in it.
31. The task should be properly decomposed. You cannot return the bottle to fridge without putting the bottle down and opening the fridge first.
32. robot_a can only do one task at a time
33. Need to close the fridge after taking bottle.
34. The robot who is near the cup (robot_b) should be the one to pick it up.
35. robot_a is not currently near the cup.

Object state: fridge(closed, robot_a near, bottle in), table(mounted robot_b), bottle(with robot_a), cup(on table, near robot_b, filled), robot_b(at cup), robot_a(at fridge, holding bottle)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Pick up the cup'}, '2': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}}
robot_a is performing the task: return the bottle to the fridge.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Return the bottle to the fridge
Correction: the bottle is already in the fridge. robot_b should pick the cup up
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Stay at the fridge', 'robot_b': 'Pick up the cup'}, '2': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}}
The task requires to bring a cup of orange juice which is assumed to be already filled in the cup on the table. The bottle is already in the fridge, so no need for robot_a to return it.
None
{'1': {'robot_a': 'Stay at the fridge', 'robot_b': 'Pick up the cup'}, '2': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Go to the cup'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Put down the cup'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set the bottle on the ground', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Pick up the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "12": {'robot_a': 'Go to the table', 'robot_b': 'Wait'},
  "13": {'robot_a': 'Put the cup on the table', 'robot_b': 'Wait'},
  "14": {'robot_a': 'Pour the orange juice into the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Take out the bottle of orange juice', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Go back to the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "11": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Put the bottle on the table', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Go back to the table', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Go back to the fridge', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "10": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the cup', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Pick up the cup', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Go back to the table', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put the bottle back in the fridge', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the bottle', 'robot_b': 'Go to the bottle'},
  "2": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "3": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "4": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "5": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Go to the cup', 'robot_b': 'Pour juice into the cup'},
  "3": {'robot_a': 'Pick up the cup', 'robot_b': 'Close the bottle'},
  "4": {'robot_a': 'Go to the fridge', 'robot_b': 'Put the bottle back in the fridge'},
  "5": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Hold the bottle', 'robot_b': 'Help robot_a open the bottle'},
  "2": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Pour juice into the cup', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Go to the fridge', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Set down the bottle', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Return the bottle to the fridge', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Close the fridge', 'robot_b': 'Pick up the cup'},
  "2": {'robot_a': 'Put the bottle in the fridge', 'robot_b': 'Hold the cup'},
  "3": {'robot_a': 'Move to the table', 'robot_b': 'Wait'}
}

Instruction: bring a cup of orange juice
Response:
{
  "1": {'robot_a': 'Stay at the fridge', 'robot_b': 'Pick up the cup'},
  "2": {'robot_a': 'Go to the table', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. The robot needs to go to the table where the cup is.
11. robot_b must be near an item to interact with it.
12. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
13. The wine bottle needs to be returned to the fridge after pouring.
14. The bottle must be closed before it can be placed back in the fridge.
15. robot_b needs to go to fridge first before storing anything inside
16. The fridge door needs to be opened before anything can be put in or taken out.
17. Robot_b cannot perform any other action while holding the bottle.
18. robot is not designed to multitask i.e., to close the fridge while holding a bottle.
19. robot_b is mounted on the table and cannot move.
20. robot_a can only hold one item at times.
21. The bottle needs to be set down before picking up the cup.
22. robot_a can only hold one item at a time.
23. robot_a cannot carry the bottle while moving
24. The bottle must be opened at the table.
25. Opening a bottle requires two robots.
26. robot_a cannot open the bottle alone.
27. Opening the bottle requires two robots to work together.
28. both robots have to work together to open the bottle
29. Only the robot that actually holds the bottle can pour the juice.
30. The robot must move to the location of the fridge to place the juice bottle back in it.
31. The task should be properly decomposed. You cannot return the bottle to fridge without putting the bottle down and opening the fridge first.
32. robot_a can only do one task at a time
33. Need to close the fridge after taking bottle.
34. The robot who is near the cup (robot_b) should be the one to pick it up.
35. robot_a is not currently near the cup.
36. The task requires to bring a cup of orange juice which is assumed to be already filled in the cup on the table. The bottle is already in the fridge, so no need for robot_a to return it.

Object state: fridge(closed, robot_a near, bottle in), table(mounted robot_b), bottle(in fridge), cup(on table, near robot_b, filled), robot_b(at cup), robot_a(at fridge)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Stay at the fridge', 'robot_b': 'Pick up the cup'}, '2': {'robot_a': 'Go to the table', 'robot_b': 'Wait'}}
robot_a is performing the task: stay at the fridge.
All robots are busy on their tasks.
********************Success! "stay at the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Stay at the fridge
Task-related knowledge: stay_pos, stay_ori

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("stay_pos", None, 1)
save_information("stay_ori", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pick up the cup.
All robots are busy on their tasks.
********************Success! "pick up the cup" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Pick up the cup
Task-related knowledge: pick_pos, pick_ori, pickup_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: go to the table.
robot_b waiting for this task to complete...
********************Success! "go to the table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Go to the table
Task-related knowledge: destination_coordinates, orientation, travel_speed.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("destination_coordinates", None, 1)
save_information("orientation", None, 1)
save_information("travel_speed", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
File 'cache/history_tmp.pkl' has been deleted successfully.
---------------------------Ready to move to next instruction...---------------------------
File 'cache/history_tmp.pkl' not found.