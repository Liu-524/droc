Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.

Object state: Object State: fridge(at corner), table(mounted robot_b), bottle(in fridge), cup(on table), robot_b(on table), robot_a(at table)
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Move to the table.', 'robot_b': 'Pour juice into the cup.'}, '6': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
robot_a is performing the task: move to the fridge.
robot_b waiting for this task to complete...
********************Success! "move to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Move to the fridge.
Task-related knowledge: move_to_pos, move_to_ori, distance_to_fridge

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("move_to_pos", current_pos, 2)
save_information("move_to_ori", current_ori, 2)
save_information("distance_to_fridge", current_distance, 2)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
********************Success! "open the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Open the fridge.
Task-related knowledge: fridge_handle_pos, fridge_handle_ori, pull_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No action is needed as the task has been completed successfully without any feedback from the human.
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle.
All robots are busy on their tasks.
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle.
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("pick_pos", "default position", 1)
save_information("pick_ori", "default orientation", 1)
save_information("pickup_height", "default height", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pick up the cup.
All robots are busy on their tasks.
********************Success! "pick up the cup" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Pick up the cup.
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Close the fridge.
Correction: you cannot close the fridge with bottle in hand. put it down first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'}, '4': {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'}, '7': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '9': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
None
robot_a cannot close the fridge while holding the bottle.
{'1': {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'}, '4': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.

Object state: fridge(open, at corner), table(mounted robot_b), bottle(in robot_a's gripper), cup(in robot_b's gripper), robot_b(on table, holding cup), robot_a(at fridge, holding bottle)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'}, '4': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
robot_a is performing the task: put the bottle down.
robot_b waiting for this task to complete...
********************Success! "put the bottle down" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle down.
Task-related knowledge: put_pos, put_ori, putdown_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("put_pos", None, 1)
save_information("put_ori", None, 1)
save_information("putdown_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the fridge.
robot_b waiting for this task to complete...
********************Success! "close the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the fridge.
Task-related knowledge: close_pos, close_ori, push_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("close_pos", None, 0)
save_information("close_ori", None, 0)
save_information("push_distance", None, 0)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle.
All robots are busy on their tasks.
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle.
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("pick_pos", "default position", 1)
save_information("pick_ori", "default orientation", 1)
save_information("pickup_height", "default height", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pour juice into the cup.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pour juice into the cup.
Correction: You cannot pour now. Wait for robot_a to bring it.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '4': {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
The juice must be poured from the bottle into the cup
robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
{'1': {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '3': {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(in robot_a's gripper), cup(in robot_b's gripper), robot_b(on table, holding cup), robot_a(at fridge, holding bottle)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '3': {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
robot_a is performing the task: bring the bottle to robot_b.
robot_b waiting for this task to complete...
********************Success! "bring the bottle to robot_b" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Bring the bottle to robot_b.
Task-related knowledge: robot_a_pos, robot_a_ori, robot_b_pos, robot_b_ori, bottle_pos, bottle_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pour juice into the cup.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pour juice into the cup.
Correction: bottle needs to be opened to pour. open it first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'}, '4': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '5': {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '8': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
Bottle needs to be opened to pour.
None.
{'1': {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '4': {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "5": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
15. Bottle needs to be opened to pour.

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(in robot_b's gripper), cup(in robot_b's gripper), robot_b(on table, holding bottle and cup), robot_a(at fridge, empty gripper)

(Note: the object states in this scenario will not change as the task was to wait)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '4': {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
robot_a is performing the task: open the bottle.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Open the bottle.
Correction: opening a bottle takes two hands. you two needs to work together.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'}, '5': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
Opening the bottle requires two robot hands
robot_a and robot_b each has only one gripper.
{'1': {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'}, '5': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "5": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
15. Bottle needs to be opened to pour.
16. Opening the bottle requires two robot hands
17. robot_a and robot_b each has only one gripper.

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(in robot_b's gripper), cup(in robot_b's gripper), robot_a(at fridge, empty gripper)

(Note: the object states in this scenario will not change as the task was to wait)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'}, '5': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
robot_a is performing the task: assist robot_b to open the bottle.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: assist robot_b to open the bottle.
Correction: robot_b needs to put down the cup first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'}, '2': {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'}, '6': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'}, '8': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
Robot needs to have a free hand to open the bottle
Robot_b can only hold one item in its gripper at a time.
{'1': {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'}, '2': {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'}, '6': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'}, '8': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "5": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
15. Bottle needs to be opened to pour.
16. Opening the bottle requires two robot hands
17. robot_a and robot_b each has only one gripper.
18. Robot needs to have a free hand to open the bottle
19. Robot_b can only hold one item in its gripper at a time.

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(in robot_b's gripper), cup(on table), robot_a(at fridge, empty gripper)

(Note: the object states in this scenario will not change as the task was to wait)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'}, '2': {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'}, '6': {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'}, '8': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
robot_b is performing the task: put cup on the table.
robot_a waiting for this task to complete...
********************Success! "put cup on the table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Put cup on the table.
Task-related knowledge: put_pos, put_ori, put_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: assist robot_b to open the bottle.
All robots are busy on their tasks.
********************Success! "assist robot_b to open the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: assist robot_b to open the bottle.
Task-related knowledge: assistant_pos, assistant_ori, approach_distance, grasp_pos_bottle, grasp_ori_bottle.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No new information to be saved.
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: open the bottle with robot_a.
All robots are busy on their tasks.
********************Success! "open the bottle with robot_a" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Open the bottle with robot_a
Task-related knowledge: robot_b_grasp_pos, robot_b_grasp_ori, robot_a_grasp_pos, robot_a_grasp_ori, twist_force

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pour juice into the cup.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pour juice into the cup.
Correction: robot_a has the bottle. Let it pour.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'}, '2': {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'}, '3': {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Wait', 'robot_b': 'Take the bottle from robot_a'}, '6': {'robot_a': 'Wait', 'robot_b': 'Put bottle back on the table.'}, '7': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'}, '8': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
The robot that holds the bottle should be the one pouring the juice.
Robot_b cannot pour the juice while the bottle is with robot_a
{'1': {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Wait', 'robot_b': 'Take the bottle from robot_a'}, '4': {'robot_a': 'Wait', 'robot_b': 'Put bottle back on the table.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'}, '6': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "5": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Take the bottle from robot_a'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Put bottle back on the table.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
15. Bottle needs to be opened to pour.
16. Opening the bottle requires two robot hands
17. robot_a and robot_b each has only one gripper.
18. Robot needs to have a free hand to open the bottle
19. Robot_b can only hold one item in its gripper at a time.
20. The robot that holds the bottle should be the one pouring the juice.
21. Robot_b cannot pour the juice while the bottle is with robot_a

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(open, in robot_a's gripper), cup(on table), robot_a(near table, holding bottle)

(Note: the object states in this scenario will not change as the task was to wait)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Wait', 'robot_b': 'Take the bottle from robot_a'}, '4': {'robot_a': 'Wait', 'robot_b': 'Put bottle back on the table.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'}, '6': {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}}
robot_a is performing the task: pour juice into the cup.
robot_b waiting for this task to complete...
********************Success! "pour juice into the cup" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pour juice into the cup.
Task-related knowledge: pour_position, pour_angle, pour_height, cup_position.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the bottle.
robot_b waiting for this task to complete...
********************Success! "close the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the bottle.
Task-related knowledge: close_pos, close_ori, force_required

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Wait
Correction: don't wait. Put the bottle back in the fridge.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Put the bottle back in the fridge.', 'robot_b': 'Pick up the cup.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}}
The orange juice bottle should be put back in the fridge.
None
{'1': {'robot_a': 'Put the bottle back in the fridge.', 'robot_b': 'Pick up the cup.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "5": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Take the bottle from robot_a'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Put bottle back on the table.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back in the fridge.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
15. Bottle needs to be opened to pour.
16. Opening the bottle requires two robot hands
17. robot_a and robot_b each has only one gripper.
18. Robot needs to have a free hand to open the bottle
19. Robot_b can only hold one item in its gripper at a time.
20. The robot that holds the bottle should be the one pouring the juice.
21. Robot_b cannot pour the juice while the bottle is with robot_a
22. The orange juice bottle should be put back in the fridge.

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(closed, in robot_a's gripper), cup(on table, not empty), robot_a(near table, holding bottle)

(Note: the object states in this scenario will not change as the task was to wait)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle back in the fridge.', 'robot_b': 'Pick up the cup.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}}
robot_a is performing the task: put the bottle back in the fridge.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Put the bottle back in the fridge.
Correction: the plan is too high-level. break it down.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Open the bottle.', 'robot_b': 'Pick up the cup.'}, '2': {'robot_a': 'Pour juice in the cup held by robot_b.', 'robot_b': 'Hold the cup under the bottle.'}, '3': {'robot_a': 'Close the bottle and put it back in the fridge.', 'robot_b': 'Wait.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}}
The task requires a detailed plan. Furthermore, the task of bringing orange juice involves pouring juice in a cup and then bringing it to the target, and not just picking up and delivering the cup.
None
{'1': {'robot_a': 'Open the bottle.', 'robot_b': 'Pick up the cup.'}, '2': {'robot_a': 'Pour juice in the cup held by robot_b.', 'robot_b': 'Hold the cup under the bottle.'}, '3': {'robot_a': 'Close the bottle and put it back in the fridge.', 'robot_b': 'Wait.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "5": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Take the bottle from robot_a'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Put bottle back on the table.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back in the fridge.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pour juice in the cup held by robot_b.', 'robot_b': 'Hold the cup under the bottle.'},
  "3": {'robot_a': 'Close the bottle and put it back in the fridge.', 'robot_b': 'Wait.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
15. Bottle needs to be opened to pour.
16. Opening the bottle requires two robot hands
17. robot_a and robot_b each has only one gripper.
18. Robot needs to have a free hand to open the bottle
19. Robot_b can only hold one item in its gripper at a time.
20. The robot that holds the bottle should be the one pouring the juice.
21. Robot_b cannot pour the juice while the bottle is with robot_a
22. The orange juice bottle should be put back in the fridge.
23. The task requires a detailed plan. Furthermore, the task of bringing orange juice involves pouring juice in a cup and then bringing it to the target, and not just picking up and delivering the cup.

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(closed, in robot_a's gripper), cup(on table, not empty), robot_a(near table, holding bottle)

(Note: the object states in this scenario will not change as the task was to wait)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Open the bottle.', 'robot_b': 'Pick up the cup.'}, '2': {'robot_a': 'Pour juice in the cup held by robot_b.', 'robot_b': 'Hold the cup under the bottle.'}, '3': {'robot_a': 'Close the bottle and put it back in the fridge.', 'robot_b': 'Wait.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}}
robot_a is performing the task: open the bottle.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Open the bottle.
Correction: don't open the bottle. bring it to the fridge.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'}, '2': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Pick up the cup.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}}
The bottle should not be opened before giving it to the requester.
None
{'1': {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'}, '2': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Pick up the cup.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "5": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Take the bottle from robot_a'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Put bottle back on the table.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back in the fridge.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pour juice in the cup held by robot_b.', 'robot_b': 'Hold the cup under the bottle.'},
  "3": {'robot_a': 'Close the bottle and put it back in the fridge.', 'robot_b': 'Wait.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'},
  "2": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
15. Bottle needs to be opened to pour.
16. Opening the bottle requires two robot hands
17. robot_a and robot_b each has only one gripper.
18. Robot needs to have a free hand to open the bottle
19. Robot_b can only hold one item in its gripper at a time.
20. The robot that holds the bottle should be the one pouring the juice.
21. Robot_b cannot pour the juice while the bottle is with robot_a
22. The orange juice bottle should be put back in the fridge.
23. The task requires a detailed plan. Furthermore, the task of bringing orange juice involves pouring juice in a cup and then bringing it to the target, and not just picking up and delivering the cup.
24. The bottle should not be opened before giving it to the requester.

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(closed, in robot_a's gripper), cup(on table, not empty), robot_a(near table, holding bottle)

(Note: the object states in this scenario will not change as the task was to wait)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'}, '2': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Pick up the cup.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}}
robot_a is performing the task: bring the bottle to the fridge.
robot_b waiting for this task to complete...
********************Success! "bring the bottle to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Bring the bottle to the fridge.
Task-related knowledge: start_pos_robot_a, end_pos_fridge, grasp_pos_bottle, grasp_ori_bottle.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait.
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: put the bottle in the fridge.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Put the bottle in the fridge.
Correction: fridge is closed. You need to open n it first
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Pick up the cup.'}, '3': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Bring cup to target.'}}
In order to put anything in the fridge, the fridge door should be opened first.
None
{'1': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Pick up the cup.'}, '3': {'robot_a': 'Close the fridge.', 'robot_b': 'Bring cup to target.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "5": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Take the bottle from robot_a'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Put bottle back on the table.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back in the fridge.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pour juice in the cup held by robot_b.', 'robot_b': 'Hold the cup under the bottle.'},
  "3": {'robot_a': 'Close the bottle and put it back in the fridge.', 'robot_b': 'Wait.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'},
  "2": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge.', 'robot_b': 'Bring cup to target.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
15. Bottle needs to be opened to pour.
16. Opening the bottle requires two robot hands
17. robot_a and robot_b each has only one gripper.
18. Robot needs to have a free hand to open the bottle
19. Robot_b can only hold one item in its gripper at a time.
20. The robot that holds the bottle should be the one pouring the juice.
21. Robot_b cannot pour the juice while the bottle is with robot_a
22. The orange juice bottle should be put back in the fridge.
23. The task requires a detailed plan. Furthermore, the task of bringing orange juice involves pouring juice in a cup and then bringing it to the target, and not just picking up and delivering the cup.
24. The bottle should not be opened before giving it to the requester.
25. In order to put anything in the fridge, the fridge door should be opened first.

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(closed, in gripper), cup(on table, not empty), robot_a(near table, holding bottle)

(Note: the object states in this scenario will not change as the task was to wait)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Pick up the cup.'}, '3': {'robot_a': 'Close the fridge.', 'robot_b': 'Bring cup to target.'}}
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Open the fridge.
Correction: you cannot open fridge with bottle in hand. put it down first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Put the bottle down on the table.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Pick up the cup.'}, '3': {'robot_a': 'Pick up the bottle and put it in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Bring cup to target'}}
Before opening the fridge, the robot must not be holding anything.
robot_a can only do one operation at a time (either holding the bottle or opening the fridge, but not both).
{'1': {'robot_a': 'Put the bottle down on the table.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle and put it in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Pick up the cup.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "5": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Take the bottle from robot_a'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Put bottle back on the table.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back in the fridge.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pour juice in the cup held by robot_b.', 'robot_b': 'Hold the cup under the bottle.'},
  "3": {'robot_a': 'Close the bottle and put it back in the fridge.', 'robot_b': 'Wait.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'},
  "2": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge.', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle down on the table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Pick up the bottle and put it in the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge.', 'robot_b': 'Bring cup to target'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
15. Bottle needs to be opened to pour.
16. Opening the bottle requires two robot hands
17. robot_a and robot_b each has only one gripper.
18. Robot needs to have a free hand to open the bottle
19. Robot_b can only hold one item in its gripper at a time.
20. The robot that holds the bottle should be the one pouring the juice.
21. Robot_b cannot pour the juice while the bottle is with robot_a
22. The orange juice bottle should be put back in the fridge.
23. The task requires a detailed plan. Furthermore, the task of bringing orange juice involves pouring juice in a cup and then bringing it to the target, and not just picking up and delivering the cup.
24. The bottle should not be opened before giving it to the requester.
25. In order to put anything in the fridge, the fridge door should be opened first.
26. Before opening the fridge, the robot must not be holding anything.
27. robot_a can only do one operation at a time (either holding the bottle or opening the fridge, but not both).

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(closed, in hand), cup(on table, not empty), robot_a(near table, holding bottle)

(Note: the object states in this scenario will not change as the task was to wait)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle down on the table.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle and put it in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Pick up the cup.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target'}}
robot_a is performing the task: put the bottle down on the table.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Put the bottle down on the table.
Correction: You are not at the table. Just put it down
Output: 
no
1
*** retrieve answer: Last Round Code ***
No code for dry-run
**Error Type: Position Inaccuracy
**Response Code: 
# Get current pose and state
current_pos, current_ori = get_current_state()

# Describe the new position, it should be a bit downward then current position
target_pos = parse_pos(f"a point a bit down to {current_pos}")

# Move to the new pose
move_gripper_to_pose(target_pos, current_ori)

# Open the gripper to release the bottle
open_gripper()

current_codeline:move_gripper_to_pose(target_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Put the bottle down on the table.
Correction: Just put the bottle on ground.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Put the bottle on the ground.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle and put it in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Pick up the cup.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target'}}
robot_a should leave the bottle in a designated place after use, not just anywhere.
none.
{'1': {'robot_a': 'Put the bottle on the ground.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle and put it in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Pick up the cup.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Move to the fridge.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Put the bottle down.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Close the fridge.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Pour juice into the cup.'},
  "7": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "9": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pick up the bottle.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to robot_b.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Hand the bottle to robot_b.', 'robot_b': 'Pick up the bottle from robot_a'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "5": {'robot_a': 'Take the bottle back.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "5": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Pick up the cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour juice into the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the bottle.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Hand the bottle to robot_a'},
  "6": {'robot_a': 'Put bottle back on the table.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_b': 'Put cup on the table.', 'robot_a': 'Wait'},
  "2": {'robot_a': 'assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a'},
  "3": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Take the bottle from robot_a'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Put bottle back on the table.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Pick up the cup.'},
  "8": {'robot_a': 'Bring the cup to the target.', 'robot_b': 'Wait'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Pour juice into the cup.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Close the bottle.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Put the bottle back in the fridge.', 'robot_b': 'Pick up the cup.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Open the bottle.', 'robot_b': 'Pick up the cup.'},
  "2": {'robot_a': 'Pour juice in the cup held by robot_b.', 'robot_b': 'Hold the cup under the bottle.'},
  "3": {'robot_a': 'Close the bottle and put it back in the fridge.', 'robot_b': 'Wait.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'},
  "2": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Bring the bottle to the fridge.', 'robot_b': 'Wait.'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Put the bottle in the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge.', 'robot_b': 'Bring cup to target.'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle down on the table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Pick up the cup.'},
  "3": {'robot_a': 'Pick up the bottle and put it in the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge.', 'robot_b': 'Bring cup to target'}
}

Instruction: Bring me some orange juice.
Response:
{
  "1": {'robot_a': 'Put the bottle on the ground.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'},
  "3": {'robot_a': 'Pick up the bottle and put it in the fridge.', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Close the fridge.', 'robot_b': 'Pick up the cup.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Bring cup to target'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. The fridge door needs to be opened before anything can be put in or taken out.
12. robot_a cannot close the fridge while holding the bottle.
13. The juice must be poured from the bottle into the cup
14. robot_a carries the bottle and robot_b bear the cup, robot_b cannot pour juice until robot_a brings the bottle to it.
15. Bottle needs to be opened to pour.
16. Opening the bottle requires two robot hands
17. robot_a and robot_b each has only one gripper.
18. Robot needs to have a free hand to open the bottle
19. Robot_b can only hold one item in its gripper at a time.
20. The robot that holds the bottle should be the one pouring the juice.
21. Robot_b cannot pour the juice while the bottle is with robot_a
22. The orange juice bottle should be put back in the fridge.
23. The task requires a detailed plan. Furthermore, the task of bringing orange juice involves pouring juice in a cup and then bringing it to the target, and not just picking up and delivering the cup.
24. The bottle should not be opened before giving it to the requester.
25. In order to put anything in the fridge, the fridge door should be opened first.
26. Before opening the fridge, the robot must not be holding anything.
27. robot_a can only do one operation at a time (either holding the bottle or opening the fridge, but not both).
28. robot_a should leave the bottle in a designated place after use, not just anywhere.

Object state: fridge(closed, at corner), table(mounted robot_b), bottle(closed, in hand), cup(on table, not empty), robot_a(near table, not holding bottle)

(Note: the object states in this scenario will not change as the task was to wait)
Robot Capacity: robot_a=['mobile base'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
Robot Capacity: robot_a=['mobile base', 'gripper'], robot_b=['mounted base', 'gripper']
{'1': {'robot_a': 'Put the bottle on the ground.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Open the fridge.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Pick up the bottle and put it in the fridge.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Close the fridge.', 'robot_b': 'Pick up the cup.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Bring cup to target'}}
robot_a is performing the task: put the bottle on the ground.
robot_b waiting for this task to complete...
********************Success! "put the bottle on the ground" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put the bottle on the ground.
Task-related knowledge: put_pos, put_ori, drop_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: open the fridge.
robot_b waiting for this task to complete...
********************Success! "open the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Open the fridge.
Task-related knowledge: fridge_handle_pos, fridge_handle_ori, pull_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No action is needed as the task has been completed successfully without any feedback from the human.
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the bottle and put it in the fridge.
robot_b waiting for this task to complete...
********************Success! "pick up the bottle and put it in the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the bottle and put it in the fridge.
Task-related knowledge: pick_pos, pick_ori, pickup_height, place_pos, place_ori, fridge_open_pos, fridge_open_ori, fridge_close_pos, fridge_close_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: close the fridge.
All robots are busy on their tasks.
********************Success! "close the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Close the fridge.
Task-related knowledge: close_pos, close_ori, push_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("close_pos", None, 0)
save_information("close_ori", None, 0)
save_information("push_distance", None, 0)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pick up the cup.
All robots are busy on their tasks.
********************Success! "pick up the cup" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Pick up the cup.
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: bring cup to target.
robot_a waiting for this task to complete...
********************Success! "bring cup to target" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Bring cup to target
Task-related knowledge: start_pos, end_pos, move_speed, move_ori

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("start_pos", None, 1)
save_information("end_pos", None, 1)
save_information("move_speed", None, 1)
save_information("move_ori", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
File 'cache/history_tmp.pkl' has been deleted successfully.
---------------------------Ready to move to next instruction...---------------------------
File 'cache/history_tmp.pkl' not found.