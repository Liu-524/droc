Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:

Object state: Object State: fridge(at corner), table(mounted robot_a), bottle(in fridge), cup(on table), robot_a(on table), robot_b(at table)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Go to the fridge'}, '2': {'robot_a': 'Wait', 'robot_b': 'Open the fridge'}, '3': {'robot_a': 'Wait', 'robot_b': 'Take the bottle out of the fridge'}, '4': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '5': {'robot_a': 'Pick up the cup.', 'robot_b': 'Go to table'}, '6': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Take bottle from robot_a'}, '7': {'robot_a': 'Wait', 'robot_b': 'Put bottle on table'}, '8': {'robot_a': 'Hand over the cup', 'robot_b': 'Take the cup'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_time, robot_a_pos, robot_a_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: go to the fridge.
robot_a waiting for this task to complete...
********************Success! "go to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Go to the fridge
Task-related knowledge: bot_b_pos, bot_b_ori, distance_to_fridge.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("bot_b_pos", current_pos, 1)
save_information("bot_b_ori", current_ori, 1)
save_information("distance_to_fridge", "unknown", 2)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_time, robot_a_pos, robot_a_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: open the fridge.
robot_a waiting for this task to complete...
********************Success! "open the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Open the fridge
Task-related knowledge: grasp_pos_fridge, grasp_ori_fridge, pull_distance_fridge.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_time, robot_a_pos, robot_a_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: take the bottle out of the fridge.
robot_a waiting for this task to complete...
********************Success! "take the bottle out of the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Take the bottle out of the fridge
Task-related knowledge: fridge_door_pos, fridge_door_ori, bottle_pos, bottle_ori, remove_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_time, robot_a_pos, robot_a_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: close the fridge.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Close the fridge
Correction: robot cannot close fridge with bottle in hand.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Go to the fridge'}, '2': {'robot_a': 'Wait', 'robot_b': 'Open the fridge'}, '3': {'robot_a': 'Wait', 'robot_b': 'Take the bottle out of the fridge'}, '4': {'robot_a': 'Wait', 'robot_b': 'Go to table'}, '5': {'robot_a': 'Pick up the cup.', 'robot_b': 'Hand bottle to robot_a'}, '6': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Go back to the fridge'}, '7': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '8': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
The fridge has to be closed after use, the wine needs to be poured into the cup and the cup has to be handed over.
Robot cannot close the fridge with the wine bottle in its hand.
{'1': {'robot_a': 'Pick up the cup.', 'robot_b': 'Pass bottle to robot_a'}, '2': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Go back to the fridge'}, '3': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '4': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle out of the fridge'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "5": {'robot_a': 'Pick up the cup.', 'robot_b': 'Hand bottle to robot_a'},
  "6": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Go back to the fridge'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "8": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge has to be closed after use, the wine needs to be poured into the cup and the cup has to be handed over.
5. Robot cannot close the fridge with the wine bottle in its hand.

Object state: fridge(open, at corner), table(mounted robot_a), bottle(in robot_b gripper), cup(on table), robot_a(on table), robot_b(at fridge)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper'] (No change in object state for 'wait' task)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Pick up the cup.', 'robot_b': 'Pass bottle to robot_a'}, '2': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Go back to the fridge'}, '3': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '4': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
robot_a is performing the task: pick up the cup.
All robots are busy on their tasks.
********************Success! "pick up the cup" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the cup.
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("pick_pos", current_pos, 1)
save_information("pick_ori", current_ori, 1)
save_information("pickup_height", "standard", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pass bottle to robot_a.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pass bottle to robot_a
Correction: close the fridge first
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pick up the cup.', 'robot_b': 'Close the fridge'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'}, '3': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
Fridge must be closed after use.
None
{'1': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'}, '3': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle out of the fridge'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "5": {'robot_a': 'Pick up the cup.', 'robot_b': 'Hand bottle to robot_a'},
  "6": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Go back to the fridge'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "8": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Pick up the cup.', 'robot_b': 'Close the fridge'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'},
  "3": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge has to be closed after use, the wine needs to be poured into the cup and the cup has to be handed over.
5. Robot cannot close the fridge with the wine bottle in its hand.
6. Fridge must be closed after use.

Object state: fridge(open, at corner), table(mounted robot_a), bottle(in robot_b gripper), cup(in robot_a gripper), robot_a(on table), robot_b(at fridge)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper'] (No change in object state for 'wait' task)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'}, '3': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '4': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_time, robot_a_pos, robot_a_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: close the fridge.
robot_a waiting for this task to complete...
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Close the fridge
Correction: robot cannot close fridge with bottle in hand. put it down first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Put bottle on table'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pick up bottle'}, '4': {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'}, '5': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
None
robot_b can't manipulate (close fridge or give to another robot) with bottle in its gripper.
{'1': {'robot_a': 'Wait', 'robot_b': 'Put bottle on table'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pick up bottle'}, '4': {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'}, '5': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle out of the fridge'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "5": {'robot_a': 'Pick up the cup.', 'robot_b': 'Hand bottle to robot_a'},
  "6": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Go back to the fridge'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "8": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Pick up the cup.', 'robot_b': 'Close the fridge'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'},
  "3": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put bottle on table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up bottle'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'},
  "5": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge has to be closed after use, the wine needs to be poured into the cup and the cup has to be handed over.
5. Robot cannot close the fridge with the wine bottle in its hand.
6. Fridge must be closed after use.
7. robot_b can't manipulate (close fridge or give to another robot) with bottle in its gripper.

Object state: fridge(open, at corner), table(mounted robot_a), bottle(in robot_b gripper), cup(in robot_a gripper), robot_a(on table), robot_b(at fridge)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper'] (No change in object state for 'wait' task)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Put bottle on table'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pick up bottle'}, '4': {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'}, '5': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_time, robot_a_pos, robot_a_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: put bottle on table.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Put bottle on table
Correction: robot_b is not at the table. just put it down.
Output: 
no
1
*** retrieve answer: Last Round Code ***
No code for dry-run
**Error Type: Position Inaccuracy
**Response Code: 
current_pos, current_ori = get_current_state()
target_pos = parse_pos("a point a bit down to current position")
move_gripper_to_pose(target_pos, current_ori)
open_gripper()

current_codeline:move_gripper_to_pose(target_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Put bottle on table
Correction: robot_b is not at the table. just put it on ground.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Put bottle on ground'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '3': {'robot_a': 'Pick up bottle from ground', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
The table is accessible only by robot_a.
Robot_b cannot reach the table while carrying items, it can only place items on the ground.
{'1': {'robot_a': 'Wait', 'robot_b': 'Put bottle on ground'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '3': {'robot_a': 'Pick up bottle from ground', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle out of the fridge'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "5": {'robot_a': 'Pick up the cup.', 'robot_b': 'Hand bottle to robot_a'},
  "6": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Go back to the fridge'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "8": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Pick up the cup.', 'robot_b': 'Close the fridge'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'},
  "3": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put bottle on table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up bottle'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'},
  "5": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put bottle on ground'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "3": {'robot_a': 'Pick up bottle from ground', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge has to be closed after use, the wine needs to be poured into the cup and the cup has to be handed over.
5. Robot cannot close the fridge with the wine bottle in its hand.
6. Fridge must be closed after use.
7. robot_b can't manipulate (close fridge or give to another robot) with bottle in its gripper.
8. The table is accessible only by robot_a.
9. Robot_b cannot reach the table while carrying items, it can only place items on the ground.

Object state: fridge(open, at corner), table(mounted robot_a), bottle(in robot_b gripper), cup(in robot_a gripper), robot_a(on table), robot_b(at fridge)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper'] (No change in object state for 'wait' task)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Put bottle on ground'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '3': {'robot_a': 'Pick up bottle from ground', 'robot_b': 'Wait'}, '4': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '5': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_time, robot_a_pos, robot_a_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: put bottle on ground.
robot_a waiting for this task to complete...
********************Success! "put bottle on ground" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Put bottle on ground
Task-related knowledge: put_pos, put_ori, ground_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("put_pos", None, 1)
save_information("put_ori", None, 1)
save_information("ground_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_time, robot_a_pos, robot_a_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: close the fridge.
robot_a waiting for this task to complete...
********************Success! "close the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Close the fridge
Task-related knowledge: push_pos, push_ori, push_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("push_pos", None, 1)
save_information("push_ori", None, 1)
save_information("push_distance", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up bottle from ground.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pick up bottle from ground
Correction: robot_a is at the table and cannot reach the bottle.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Pick up the bottle'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '3': {'robot_a': 'Wait', 'robot_b': 'Go to the table'}, '4': {'robot_a': 'Receive bottle from robot_b', 'robot_b': 'Handover bottle to robot_a'}, '5': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
None
Robot_a cannot move from its mounted location on the table.
{'1': {'robot_a': 'Wait', 'robot_b': 'Pick up the bottle'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '3': {'robot_a': 'Wait', 'robot_b': 'Go to the table'}, '4': {'robot_a': 'Receive bottle from robot_b', 'robot_b': 'Handover bottle to robot_a'}, '5': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle out of the fridge'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "5": {'robot_a': 'Pick up the cup.', 'robot_b': 'Hand bottle to robot_a'},
  "6": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Go back to the fridge'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "8": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Pick up the cup.', 'robot_b': 'Close the fridge'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'},
  "3": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put bottle on table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up bottle'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pass bottle to robot_a'},
  "5": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put bottle on ground'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "3": {'robot_a': 'Pick up bottle from ground', 'robot_b': 'Wait'},
  "4": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pick up the bottle'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to the table'},
  "4": {'robot_a': 'Receive bottle from robot_b', 'robot_b': 'Handover bottle to robot_a'},
  "5": {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge has to be closed after use, the wine needs to be poured into the cup and the cup has to be handed over.
5. Robot cannot close the fridge with the wine bottle in its hand.
6. Fridge must be closed after use.
7. robot_b can't manipulate (close fridge or give to another robot) with bottle in its gripper.
8. The table is accessible only by robot_a.
9. Robot_b cannot reach the table while carrying items, it can only place items on the ground.
10. Robot_a cannot move from its mounted location on the table.

Object state: fridge(closed), robot_a(on table), robot_b(at fridge), bottle(on ground), cup(in robot_a gripper)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper'] (No change in object state for 'wait' task)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Pick up the bottle'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge'}, '3': {'robot_a': 'Wait', 'robot_b': 'Go to the table'}, '4': {'robot_a': 'Receive bottle from robot_b', 'robot_b': 'Handover bottle to robot_a'}, '5': {'robot_a': 'Pour wine into the cup', 'robot_b': 'Wait'}, '6': {'robot_a': 'Hand over the cup', 'robot_b': 'Wait'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_time, robot_a_pos, robot_a_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pick up the bottle.
robot_a waiting for this task to complete...
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Pick up the bottle
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_time, robot_a_pos, robot_a_ori.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: close the fridge.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Close the fridge
Correction: fridge is already closed.
Output: 
no
1
*** retrieve answer: Last Round Code ***
No code for dry-run
**Error Type: Position Inaccuracy
**Response Code: 
print("The fridge is already closed, no further action required.")

Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Close the fridge
Correction: fridge is already closed, bring the bottle to the table.
Output: 
yes
**Error Type: Planning error
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:

Object state: Object State: fridge(at corner), table(mounted robot_a), bottle(in fridge), cup(on table), robot_a(on table), robot_b(at table)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'}, '3': {'robot_a': 'Grab the cup.', 'robot_b': 'Close the fridge.'}, '4': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Put the bottle back in the fridge.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '6': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'}, '7': {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'}, '8': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: open the fridge.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Open the fridge.
Correction: it needs to go to fridge first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'}, '5': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'}, '7': {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'}, '8': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '9': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'}, '10': {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'}, '11': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
The fridge needs to be approached before it can be opened.
robot_b needs to move to the fridge before opening it.
{'1': {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'}, '5': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'}, '7': {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'}, '8': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '9': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'}, '10': {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'}, '11': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.

Object state: Object State: fridge(at corner), table(mounted robot_a), bottle(in fridge), cup(on table), robot_a(on table), robot_b(at table)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'}, '5': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'}, '6': {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'}, '7': {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'}, '8': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '9': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'}, '10': {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'}, '11': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: grab the cup.
All robots are busy on their tasks.
********************Success! "grab the cup" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Grab the cup.
Task-related knowledge: grab_pos, grab_ori, lift_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: go to the fridge.
All robots are busy on their tasks.
********************Success! "go to the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Go to the fridge.
Task-related knowledge: destination_pos, destination_ori, trajectory_path.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Save_information("destination_pos", None, 1)
Save_information("destination_ori", None, 1)
Save_information("trajectory_path", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: open the fridge.
robot_a waiting for this task to complete...
********************Success! "open the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Open the fridge.
Task-related knowledge: grasp_pos, grasp_ori, pull_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("grasp_pos", "None", 2)
save_information("grasp_ori", "None", 2)
save_information("pull_distance", "None", 2)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: take the bottle.
robot_a waiting for this task to complete...
********************Success! "take the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Take the bottle.
Task-related knowledge: bottle_pos, bottle_ori, lift_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("bottle_pos", None, 1)
save_information("bottle_ori", None, 1)
save_information("lift_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: go to robot_a.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Go to robot_a.
Correction: close the fridge first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'}, '6': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'}, '7': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'}, '8': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
Fridge should be closed after use.
None
{'1': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'}, '3': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.

Object state: fridge(open), table(mounted robot_a), bottle(in gripper), cup(in gripper), robot_a(at table), robot_b(at fridge)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'}, '3': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'}, '4': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: close the fridge.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Close the fridge.
Correction: robot cannot close fridge door with bottle in hand. Put it down first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'}, '4': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'}, '6': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
Robot should not close fridge door with bottle in hand.
robot_b can only hold one item at a time.
{'1': {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '3': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'}, '4': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.

Object state: fridge(open), table(mounted robot_a), bottle(in gripper), cup(in gripper), robot_a(at table), robot_b(at fridge)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '3': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'}, '4': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: put the bottle on the table.
robot_a waiting for this task to complete...
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Put the bottle on the table.
Correction: table is far. put it on ground.
Output: 
no
1
*** retrieve answer: Last Round Code ***
No code for dry-run
**Error Type: Position Inaccuracy
**Response Code: 
# Adjusting task to place the bottle on the ground instead of table
current_pos, current_ori = get_current_state()
ground_pos, ground_ori = get_task_pose("put the bottle on the ground")
target_pos = parse_pos(f"a point down to {ground_pos}")
move_gripper_to_pose(target_pos, ground_ori)
open_gripper()

current_codeline:move_gripper_to_pose(target_pos, ground_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Put the bottle on the table.
Correction: robot is not at the table. put the bottle on ground instead.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '3': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'}, '4': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
The robot need to be at the same location as the object to perform tasks involving the object.
Robot_b is not at table to put the bottle.
{'1': {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '3': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'}, '4': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.

Object state: fridge(open), table(mounted robot_a), bottle(in gripper), cup(in gripper), robot_a(at table), robot_b(at fridge)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '3': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'}, '4': {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: put the bottle on the ground.
robot_a waiting for this task to complete...
********************Success! "put the bottle on the ground" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Put the bottle on the ground.
Task-related knowledge: place_pos, place_ori, place_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("place_pos", None, 1)
save_information("place_ori", None, 1)
save_information("place_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: close the fridge.
robot_a waiting for this task to complete...
********************Success! "close the fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Close the fridge.
Task-related knowledge: push_pos, push_ori, push_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pour wine into cup.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pour wine into cup.
Correction: robot_a don't have the bottle yet. Wait for robot_b.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'}, '4': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
Bottle needs to be hold by the robot before pouring wine into the cup.
robot_a only has one gripper.
{'1': {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'}, '2': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.

Object state: fridge(closed), table(mounted robot_a), bottle(on ground), cup(in gripper), robot_a(at table), robot_b(at fridge)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'}, '2': {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: take the bottle.
robot_a waiting for this task to complete...
********************Success! "take the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Take the bottle.
Task-related knowledge: bottle_pos, bottle_ori, lift_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("bottle_pos", None, 1)
save_information("bottle_ori", None, 1)
save_information("lift_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pour wine into cup.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Pour wine into cup.
Correction: wait until robot_b brings the bottle
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
Wine must be poured into the cup while the bottle and cup are held by the same robot.
robot_a has limited reach and cannot retrieve the bottle from robot_b.
{'1': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '2': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.

Object state: fridge(closed), table(mounted robot_a), bottle(in gripper), cup(in gripper), robot_a(at table), robot_b(at fridge)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '2': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pour wine into cup.
robot_a waiting for this task to complete...
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pour wine into cup
Correction: go to the table first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Go to table'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
The robot needs to go to the table where the cup is.
robot_b must be near an item to interact with it.
{'1': {'robot_a': 'Wait', 'robot_b': 'Go to table'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.

Object state: fridge(closed), table(mounted robot_a), bottle(in gripper), cup(on table), robot_a(at table), robot_b(at fridge)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Go to table'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: go to table.
robot_a waiting for this task to complete...
********************Success! "go to table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Go to table
Task-related knowledge: destination_pos, destination_ori, movement_speed

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No feedback information to store
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pour wine into cup.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pour wine into cup
Correction: open the bottle before pouring.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Go to table'}, '2': {'robot_a': 'Wait', 'robot_b': 'Open the bottle'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '4': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
Before pouring, the bottle needs to be opened.
None
{'1': {'robot_a': 'Wait', 'robot_b': 'Open the bottle'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the bottle'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.
17. Before pouring, the bottle needs to be opened.

Object state: fridge(closed), table(mounted robot_a), bottle(closed, in gripper), cup(on table), robot_a(at table), robot_b(at table)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Open the bottle'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: open the bottle.
robot_a waiting for this task to complete...
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Open the bottle
Correction: it takes both robots to open a bottle.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
Opening the wine bottle requires both robots.
None
{'1': {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the bottle'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.
17. Before pouring, the bottle needs to be opened.
18. Opening the wine bottle requires both robots.

Object state: fridge(closed), table(mounted robot_a), bottle(closed, in gripper), cup(on table), robot_a(at table), robot_b(at table)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '3': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: assist robot_b to open the bottle.
All robots are busy on their tasks.
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_a: Assist robot_b to open the bottle.
Correction: robot_a cannot help with cup in its hand. put the cup down first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'}, '2': {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
None
robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
{'1': {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'}, '2': {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the bottle'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.
17. Before pouring, the bottle needs to be opened.
18. Opening the wine bottle requires both robots.
19. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.

Object state: fridge(closed), table(mounted robot_a, cup), bottle(closed, in gripper), robot_a(at table), robot_b(at table)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'}, '2': {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: put cup on table.
robot_a waiting for this task to complete...
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Put cup on table.
Correction: robot_b does not have the cup. robot_a need to put the cup down.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Wait', 'robot_b': 'Pick up bottle.'}, '3': {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup.'}, '6': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
None
The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
{'1': {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the bottle'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pick up bottle.'},
  "3": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.
17. Before pouring, the bottle needs to be opened.
18. Opening the wine bottle requires both robots.
19. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
20. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.

Object state: fridge(closed), table(mounted robot_a, cup), bottle(closed, in gripper), robot_a(at table), robot_b(at table)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup.'}, '5': {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}}
robot_a is performing the task: put cup on table.
robot_b waiting for this task to complete...
********************Success! "put cup on table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Put cup on table.
Task-related knowledge: put_pos, put_ori, put_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("put_pos", None, 1)
save_information("put_ori", None, 1)
save_information("put_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Wait
Task-related knowledge: None, as the task implies no action needs to be taken by the robot.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("task-related knowledge", "None, as the task implies no action needs to be taken by the robot.", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: assist robot_b to open the bottle.
All robots are busy on their tasks.
********************Success! "assist robot_b to open the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Assist robot_b to open the bottle.
Task-related knowledge: assistant_pos, assistant_ori, approach_distance, grasp_pos_bottle, grasp_ori_bottle.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

No information added: No additional data provided to infer from
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: open the bottle with robot_a.
All robots are busy on their tasks.
********************Success! "open the bottle with robot_a" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Open the bottle with robot_a.
Task-related knowledge: robot_b_grasp_pos, robot_b_grasp_ori, robot_a_grasp_pos, robot_a_grasp_ori, twist_force

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pick up cup from table.
robot_a waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Pick up cup from table.
Correction: robot_b has bottle in its hand, just pour to the cup.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'}, '2': {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'}, '3': {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'}, '4': {'robot_a': 'Wait', 'robot_b': 'Wait'}, '5': {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Wait'}, '6': {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}}
Robot should pour wine while the cup is on the table.
robot_b can only hold one item at a time.
{'1': {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'}, '2': {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Wait'}, '3': {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the bottle'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pick up bottle.'},
  "3": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.
17. Before pouring, the bottle needs to be opened.
18. Opening the wine bottle requires both robots.
19. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
20. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
21. Robot should pour wine while the cup is on the table.
22. robot_b can only hold one item at a time.

Object state: fridge(closed), table(mounted robot_a, cup), bottle(open, in robot_b's gripper), robot_a(at table), robot_b(at table, holding open bottle)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'}, '2': {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Wait'}, '3': {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}}
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pour wine into the cup on the table.
robot_a waiting for this task to complete...
********************Success! "pour wine into the cup on the table" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Pour wine into the cup on the table.
Task-related knowledge: pour_start_pos, pour_start_ori, pour_end_pos, pour_end_ori, tilt_angle.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Save_information("pour_start_pos", None, 1)
Save_information("pour_start_ori", None, 1)
Save_information("pour_end_pos", None, 1)
Save_information("pour_end_ori", None, 1)
Save_information("tilt_angle", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: pick up the cup of wine.
robot_b waiting for this task to complete...
********************Success! "pick up the cup of wine" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the cup of wine
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("pick_pos", pick_pos, 1)
save_information("pick_ori", pick_ori, 1)
save_information("pickup_height", pickup_height, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: wait.
robot_b waiting for this task to complete...
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Wait
Correction: robot_b needs to return the bottle to fridge.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'}, '2': {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Put bottle back in fridge'}, '3': {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}}
The wine bottle needs to be returned to the fridge after pouring.
None
{'1': {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Put bottle back in fridge'}, '2': {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the bottle'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pick up bottle.'},
  "3": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "2": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Put bottle back in fridge'},
  "3": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.
17. Before pouring, the bottle needs to be opened.
18. Opening the wine bottle requires both robots.
19. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
20. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
21. Robot should pour wine while the cup is on the table.
22. robot_b can only hold one item at a time.
23. The wine bottle needs to be returned to the fridge after pouring.

Object state: fridge(closed), table(mounted robot_a, empty), cup(with wine, in robot_a's gripper), bottle(open, in robot_b's gripper), robot_a(at table, holding cup with wine), robot_b(at table, holding open bottle)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Put bottle back in fridge'}, '2': {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}}
robot_a is performing the task: pick up the cup of wine.
All robots are busy on their tasks.
********************Success! "pick up the cup of wine" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Pick up the cup of wine
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("pick_pos", pick_pos, 1)
save_information("pick_ori", pick_ori, 1)
save_information("pickup_height", pickup_height, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: put bottle back in fridge.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Put bottle back in fridge
Correction: close bottle before returning it
Output: 
yes
**Error Type: Planning error
{'1': {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Close the bottle'}, '2': {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Put bottle back in fridge'}}
The bottle must be closed before it can be placed back in the fridge.
None
{'1': {'robot_b': 'Close the bottle', 'robot_a': 'Wait'}, '2': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the bottle'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pick up bottle.'},
  "3": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "2": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Put bottle back in fridge'},
  "3": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Close the bottle'},
  "2": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Put bottle back in fridge'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.
17. Before pouring, the bottle needs to be opened.
18. Opening the wine bottle requires both robots.
19. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
20. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
21. Robot should pour wine while the cup is on the table.
22. robot_b can only hold one item at a time.
23. The wine bottle needs to be returned to the fridge after pouring.
24. The bottle must be closed before it can be placed back in the fridge.

Object state: fridge(closed), table(mounted robot_a, empty), cup(empty, in robot_a's gripper), bottle(open, in robot_b's gripper), robot_a(at table, not holding anything), robot_b(at table, holding open bottle)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_b': 'Close the bottle', 'robot_a': 'Wait'}, '2': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Deliver cup of wine.'}}
robot_b is performing the task: close the bottle.
robot_a waiting for this task to complete...
********************Success! "close the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Close the bottle
Task-related knowledge: grasp_pos, grasp_ori, tighten_force.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: put bottle back in fridge.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Put bottle back in fridge
Correction: this step needs to be broken down.
Output: 
no
3
*** retrieve answer: Last Round Code ***
**Error Type: Position Inaccuracy
**Response Code: 
# Step 1: Open the fridge
fridge_pos, fridge_ori = get_task_pose("fridge")
target_pos = parse_pos(f"a point right before the {fridge_pos}") 
move_gripper_to_pose(target_pos, fridge_ori)

# Step 2: Move it to fridge's level
target_pos_up = parse_pos(f"a point a bit upwards {target_pos}")
move_gripper_to_pose(target_pos_up, current_ori)

# Step 3: Move inside the fridge
target_pos = parse_pos(f"a point forward {target_pos_up}")
move_gripper_to_pose(target_pos, current_ori)

# Step 4: Release the bottle
open_gripper()

# Step 5: Leave the fridge
target_pos = parse_pos(f"a point back {target_pos}")
move_gripper_to_pose(target_pos, current_ori)

# Step 6: Close the fridge
target_pos = parse_pos(f"a point forward {target_pos}")
move_gripper_to_pose(target_pos, current_ori)

current_codeline:move_gripper_to_pose(target_pos, fridge_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Put bottle back in fridge
Correction: go to the fridge first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_b': 'Close the bottle', 'robot_a': 'Wait'}, '2': {'robot_b': 'Move to fridge', 'robot_a': 'Wait'}, '3': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Deliver cup of wine.'}}
robot_b needs to go to fridge first before storing anything inside
None
{'1': {'robot_b': 'Move to fridge', 'robot_a': 'Wait'}, '2': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the bottle'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pick up bottle.'},
  "3": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "2": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Put bottle back in fridge'},
  "3": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Close the bottle'},
  "2": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Put bottle back in fridge'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_b': 'Close the bottle', 'robot_a': 'Wait'},
  "2": {'robot_b': 'Move to fridge', 'robot_a': 'Wait'},
  "3": {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.
17. Before pouring, the bottle needs to be opened.
18. Opening the wine bottle requires both robots.
19. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
20. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
21. Robot should pour wine while the cup is on the table.
22. robot_b can only hold one item at a time.
23. The wine bottle needs to be returned to the fridge after pouring.
24. The bottle must be closed before it can be placed back in the fridge.
25. robot_b needs to go to fridge first before storing anything inside

Object state: fridge(closed), table(mounted robot_a, empty), cup(empty, in robot_a's gripper), bottle(closed, in robot_b's gripper), robot_a(at table, not holding anything), robot_b(at table, holding closed bottle)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_b': 'Move to fridge', 'robot_a': 'Wait'}, '2': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Deliver cup of wine.'}}
robot_b is performing the task: move to fridge.
robot_a waiting for this task to complete...
********************Success! "move to fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Move to fridge
Task-related knowledge: move_destination, move_speed, move_path

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("move_destination", "fridge", 1)
save_information("move_speed", None, 1)
save_information("move_path", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: put bottle back in fridge.
All robots are busy on their tasks.
current_codeline:move_gripper_to_pose(moveup_pos, current_ori)
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Put bottle back in fridge
Correction: open the fridge door first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_b': 'Move to fridge', 'robot_a': 'Wait'}, '2': {'robot_b': 'Open the fridge door.', 'robot_a': 'Wait'}, '3': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Wait'}, '4': {'robot_b': 'Close the fridge door.', 'robot_a': 'Deliver cup of wine.'}}
The fridge door needs to be opened before anything can be put in or taken out.
None
{'1': {'robot_b': 'Open the fridge door.', 'robot_a': 'Wait'}, '2': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Wait'}, '3': {'robot_b': 'Close the fridge door.', 'robot_a': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the bottle'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pick up bottle.'},
  "3": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "2": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Put bottle back in fridge'},
  "3": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Close the bottle'},
  "2": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Put bottle back in fridge'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_b': 'Close the bottle', 'robot_a': 'Wait'},
  "2": {'robot_b': 'Move to fridge', 'robot_a': 'Wait'},
  "3": {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_b': 'Move to fridge', 'robot_a': 'Wait'},
  "2": {'robot_b': 'Open the fridge door.', 'robot_a': 'Wait'},
  "3": {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Wait'},
  "4": {'robot_b': 'Close the fridge door.', 'robot_a': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.
17. Before pouring, the bottle needs to be opened.
18. Opening the wine bottle requires both robots.
19. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
20. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
21. Robot should pour wine while the cup is on the table.
22. robot_b can only hold one item at a time.
23. The wine bottle needs to be returned to the fridge after pouring.
24. The bottle must be closed before it can be placed back in the fridge.
25. robot_b needs to go to fridge first before storing anything inside
26. The fridge door needs to be opened before anything can be put in or taken out.

Object state: fridge(closed), table(mounted robot_a, empty), cup(empty, in robot_a's gripper), bottle(closed, in robot_b's gripper), robot_a(at fridge, not holding anything), robot_b(at table, holding closed bottle)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_b': 'Open the fridge door.', 'robot_a': 'Wait'}, '2': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Wait'}, '3': {'robot_b': 'Close the fridge door.', 'robot_a': 'Deliver cup of wine.'}}
robot_b is performing the task: open the fridge door.
robot_a waiting for this task to complete...
Please determine whether the given correction indicates there's an error beyond the task's scope.

Task: open the top shelf
Correction: move right a little bit
Output: no

Task: pick up the apple.
Correction: that's wrong. move left please
Output: no

Task: put the apple into the fridge
Correction: you should open the fridge first
Output: yes

Task: open the fridge
Correction: wrong detection
Output: no

Task: pick up the pen
Correction: no, pick the red pen
Output: yes

Task: robot_b: Open the fridge door.
Correction: robot cannot open door with bottle in hand. put it on the ground first.
Output: 
yes
**Error Type: Planning error
{'1': {'robot_b': 'Put bottle on the ground', 'robot_a': 'Wait'}, '2': {'robot_b': 'Open the fridge door.', 'robot_a': 'Wait'}, '3': {'robot_b': 'Pick up the bottle', 'robot_a': 'Wait'}, '4': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Wait'}, '5': {'robot_b': 'Close the fridge door.', 'robot_a': 'Deliver cup of wine.'}}
None
Robot_b cannot perform any other action while holding the bottle.
{'1': {'robot_b': 'Put bottle on the ground', 'robot_a': 'Wait'}, '2': {'robot_b': 'Open the fridge door.', 'robot_a': 'Wait'}, '3': {'robot_b': 'Pick up the bottle', 'robot_a': 'Wait'}, '4': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Wait'}, '5': {'robot_b': 'Close the fridge door.', 'robot_a': 'Deliver cup of wine.'}}
File 'cache/history_tmp.pkl' has been deleted successfully.
Imagine you are working with two robot equipped with a two-fingered gripper for grasping. The robots' mission is to collaborate and complete tasks based on a given instructions. However, they may struggle with high-level instructions
Your role is to understand those instructions and break them down into smaller, actionable sub-tasks. You will also assign the tasks to specific robot and order the tasks. If there is ambiguity in deciding the object given existing information, just list all possible objects like Example 1.
If one robot needs to wait for the other to finish a particular sub-task, assign them task "wait" at the same line. 
Here are some examples:

Object state: fridge(closed), green apple(on table), red apple(on table)
Robot capacity: robot_a=['mobile base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the apple in the fridge.
Response:
{
  "1": {"robot_a" : "Open the fridge.", "robot_b" : "Pick up apple_x." },
  "2": {"robot_a" : "Wait", "robot_b" : "Put apple_x into the fridge.",},
  "3": {"robot_a": "Close the fridge.", "robot_b" : "Wait",},
}

Object state: cabinet(closed)
Robot capacity: robot_a=[], robot_b=[]
Instruction: open the top white cabinet
Response:
{
  "1": {"robot_a": "Open the cabinet.", "robot_b": "Wait"}
}

Object state: N/A
Robot capacity: robot_a=['fixed base', 'gripper'], robot_b=['mobile base', 'gripper']
Instruction: put the spoon into the bottom black shelf
Response:
{
  "1": {"robot_a" : "Open the bottom black shelf.", "robot_b" : "Go to the spoon"},
  "2": {"robot_a" : "Wait", "robot_b" : "Pick up the spoon." },
  "3": {"robot_a" : "Wait", "robot_b": "Go to robot_a"},
  "4": {"robot_a" : "Take spoon", "robot_b" : "Give spoon to robot_a"},
  "5": {"robot_a" : "Put spoon into the bottom black shelf", "robot_b": "Wait"}
  "6": {"robot_a" : "Close the bottom black shelf.", "robot_b" : "Wait"}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "5": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Go to the fridge.'},
  "7": {'robot_a': 'Wait', 'robot_b': 'Put the bottle back in the fridge.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "9": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Go to robot_a'},
  "10": {'robot_a': 'Wait', 'robot_b': 'Take cup from robot_a.'},
  "11": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Grab the cup.', 'robot_b': 'Go to the fridge.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "6": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "7": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "8": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the table.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Go to robot_a.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Give cup to robot_b.', 'robot_b': 'Take cup from robot_a.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put the bottle on the ground.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Close the fridge.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "4": {'robot_a': 'Pour wine into cup.', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Take the bottle.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Go to table'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Open the bottle'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Put cup on table.'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Wait', 'robot_b': 'Pick up bottle.'},
  "3": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Pick up cup from table.'},
  "5": {'robot_a': 'Wait', 'robot_b': 'Pour wine into cup.'},
  "6": {'robot_a': 'Wait', 'robot_b': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Put cup on table.', 'robot_b': 'Wait'},
  "2": {'robot_a': 'Assist robot_b to open the bottle.', 'robot_b': 'Open the bottle with robot_a.'},
  "3": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "4": {'robot_a': 'Wait', 'robot_b': 'Wait'},
  "5": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Wait'},
  "6": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Wait', 'robot_b': 'Pour wine into the cup on the table.'},
  "2": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Put bottle back in fridge'},
  "3": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Wait'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_a': 'Pick up the cup of wine', 'robot_b': 'Close the bottle'},
  "2": {'robot_a': 'Deliver cup of wine.', 'robot_b': 'Put bottle back in fridge'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_b': 'Close the bottle', 'robot_a': 'Wait'},
  "2": {'robot_b': 'Move to fridge', 'robot_a': 'Wait'},
  "3": {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_b': 'Move to fridge', 'robot_a': 'Wait'},
  "2": {'robot_b': 'Open the fridge door.', 'robot_a': 'Wait'},
  "3": {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Wait'},
  "4": {'robot_b': 'Close the fridge door.', 'robot_a': 'Deliver cup of wine.'}
}

Instruction: bring a cup of wine.
Response:
{
  "1": {'robot_b': 'Put bottle on the ground', 'robot_a': 'Wait'},
  "2": {'robot_b': 'Open the fridge door.', 'robot_a': 'Wait'},
  "3": {'robot_b': 'Pick up the bottle', 'robot_a': 'Wait'},
  "4": {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Wait'},
  "5": {'robot_b': 'Close the fridge door.', 'robot_a': 'Deliver cup of wine.'}
}

Rules:
1. In each sub-task of your response, the robot should manipulate one object and only move its gripper once.
2. If you think the instruction is low-level enough, just repeat the instruction in your response
3. Omit assumptions and only follow a json format after the word Response:
4. The fridge needs to be approached before it can be opened.
5. robot_b needs to move to the fridge before opening it.
6. Fridge should be closed after use.
7. Robot should not close fridge door with bottle in hand.
8. robot_b can only hold one item at a time.
9. The robot need to be at the same location as the object to perform tasks involving the object.
10. Robot_b is not at table to put the bottle.
11. Bottle needs to be hold by the robot before pouring wine into the cup.
12. robot_a only has one gripper.
13. Wine must be poured into the cup while the bottle and cup are held by the same robot.
14. robot_a has limited reach and cannot retrieve the bottle from robot_b.
15. The robot needs to go to the table where the cup is.
16. robot_b must be near an item to interact with it.
17. Before pouring, the bottle needs to be opened.
18. Opening the wine bottle requires both robots.
19. robot_a only has one gripper and can only grasp one thing in hand at a time. It cannot help opening the bottle when holding a cup.
20. The task robot_b is assigned to execute requires the cup to be on the table. However, at this moment, the cup is with robot_a, and robot_b cannot execute the task until robot_a puts the cup on the table.
21. Robot should pour wine while the cup is on the table.
22. robot_b can only hold one item at a time.
23. The wine bottle needs to be returned to the fridge after pouring.
24. The bottle must be closed before it can be placed back in the fridge.
25. robot_b needs to go to fridge first before storing anything inside
26. The fridge door needs to be opened before anything can be put in or taken out.
27. Robot_b cannot perform any other action while holding the bottle.

Object state: fridge(closed), table(mounted robot_a, empty), cup(empty, in robot_a's gripper), bottle(closed, not gripped), robot_a(at fridge, not holding anything), robot_b(at table, not holding anything)
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
Robot Capacity: robot_a=['mounted base', 'gripper'], robot_b=['mobile base', 'gripper']
{'1': {'robot_b': 'Put bottle on the ground', 'robot_a': 'Wait'}, '2': {'robot_b': 'Open the fridge door.', 'robot_a': 'Wait'}, '3': {'robot_b': 'Pick up the bottle', 'robot_a': 'Wait'}, '4': {'robot_b': 'Put bottle back in fridge', 'robot_a': 'Wait'}, '5': {'robot_b': 'Close the fridge door.', 'robot_a': 'Deliver cup of wine.'}}
robot_b is performing the task: put bottle on the ground.
robot_a waiting for this task to complete...
********************Success! "put bottle on the ground" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Put bottle on the ground
Task-related knowledge: put_pos, put_ori, put_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("put_pos", "ground", 1)
save_information("put_ori", "upright", 1)
save_information("put_height", "0cm", 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' has been deleted successfully.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: open the fridge door.
robot_a waiting for this task to complete...
********************Success! "open the fridge door" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Open the fridge door.
Task-related knowledge: grasp_pos, grasp_ori, pull_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: pick up the bottle.
robot_a waiting for this task to complete...
********************Success! "pick up the bottle" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Pick up the bottle
Task-related knowledge: pick_pos, pick_ori, pickup_height

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("pick_pos", None, 1)
save_information("pick_ori", None, 1)
save_information("pickup_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: put bottle back in fridge.
robot_a waiting for this task to complete...
********************Success! "put bottle back in fridge" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Put bottle back in fridge
Task-related knowledge: put_pos, put_ori, open_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: wait.
robot_a waiting for this task to complete...
********************Success! "wait" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Wait
Task-related knowledge: wait_duration.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("wait_duration", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_b is performing the task: close the fridge door.
All robots are busy on their tasks.
********************Success! "close the fridge door" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_b: Close the fridge door.
Task-related knowledge: push_pos, push_ori, push_distance.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
robot_a is performing the task: deliver cup of wine.
All robots are busy on their tasks.
********************Success! "deliver cup of wine" is fulfilled !!!!!********************
--------------------------------------------------------------------------------
*at save_info*
A robot is doing a task, and a human is giving it feedback to help it complete the task correctly. 
Your first task is to use the command 'save_information(info_name, info_value, response_round: int)' to store the correct value of "task-related knowledge".
Your second task is to determine whether there are additional waypoints needed. To do this, you need to distinguish between positional adjustments and waypoints based on analyzing human's feedback.

Below are some examples:
Interaction history:
'''
Task: Insert the pen to the holder, with the pen already in hand.
# Task-related knowledge: insertion_pos, insertion_ori, insertion_depth

Response 1:
'''
insert_pos, insert_ori = get_task_pose("insert the pen to the holder")
move_gripper_to_pose(insert_pos, insert_ori)
current_pos, current_ori = get_current_state()
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Interrupted at codeline "move_gripper_to_pose(insert_pos, insert_ori)".
Human feedback: move forward a bit

Response to feedback 2:
'''
current_pos, current_ori = get_current_state()
target_pos = parse_pos(f"a point a bit backward to {current_pos}")
move_gripper_to_pose(target_pos, current_ori)

'''
Outcome: Done.
Human feedback: move left and tilt up a little bit

Response to feedback 3:
'''
movedown_pos = parse_pos(f"a point 5cm to {current_pos}.")
move_gripper_to_pose(movedown_pos, current_ori)
open_gripper()
'''
Outcome: Done.
Human feedback: Done.
'''

Your response:
save_information("insertion_pos", current_pos, 4)
save_information("insertion_ori", target_ori, 4)
save_information("insertion_depth", "5cm", 5)
Additional waypoint needed: None

Interaction history:
'''
Task: robot_a: Deliver cup of wine.
Task-related knowledge: start_pos, end_pos, grasp_ori, transport_height.

Response 1:
'''
No code for dry-run
'''
Outcome: Done.
Human feedback: Done
'''

Your response:

save_information("start_pos", None, 1)
save_information("end_pos", None, 1)
save_information("grasp_ori", None, 1)
save_information("transport_height", None, 1)
Additional waypoint needed: None
defaultdict(<class 'dict'>, {})
--------------------------------------------------------------------------------
File 'cache/tmp_info.pkl' not found.
File 'cache/history_tmp.pkl' has been deleted successfully.
---------------------------Ready to move to next instruction...---------------------------
File 'cache/history_tmp.pkl' not found.